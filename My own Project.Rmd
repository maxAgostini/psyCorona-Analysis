---
title: "PsyCorona"
author: "Maximilian Agostini"
date: "May 2020"
output:
  html_document:
    code_folding: hide
    mathjax: default
    theme: united
    toc: yes
    toc_float: yes
    number_sections: TRUE
  pdf_document:
    toc: yes
---

<style type="text/css">
.main-container {
  max-width: 1200px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r setup, include=FALSE}
cat("\014") # clear console
rm(list=ls()) # clear workspace
gc # garbage collector

require(pacman)
p_load(metafor, tidyr, dplyr, tinytex, knitr, kableExtra, DescTools, reshape2, metaSEM, lavaan, semPlot, psych, ggplot2, MplusAutomation, bmlm)

set.seed(52) # set overall random seed for reproducibility
```

# Load Data
```{r LoadRawBase, echo=T, warning=F, message=F}
# Import Data
dtRaw <- haven::read_spss(dir("data", pattern = "Agostini", full.names = TRUE, ignore.case = TRUE))
```

# Prepare Data
## Cleaning
```{r clean, echo=T, warning=F, message=F}
# change all -99 into NA
  dtRaw[dtRaw == -99] <- NA

# add running number as pp
  dtRaw$PPID <- c(1:nrow(dtRaw))

# make relevant dfs
dtFull <- dtRaw

# make relevant vars numeric
dtFull <- dtFull %>%
  dplyr::mutate_at(vars(matches(
    paste(c("aff", "PFS", "fail", "happy", "lifeSat", "MLQ", "c19ProSo"), collapse = "|"), -contains("DO"))), #vars changed
    as.numeric) #function for change

# create between subjects baseline df
dtCtry <- dtRaw %>% 
  group_by(coded_country) %>% # group by country
  filter(n() > 100) # remove countries with less than 100 people
dtCtry <- dtCtry %>% #needs to be ungrouped for the scale calculation
  ungroup()
rm(dtRaw)
```

### Calc relevant stats
```{r}
# calculate number of measurement points (based on hope variable as most people answered it)
tmp <- dtFull %>%
  select(contains("c19Hope"),
         -contains("DO"))%>%
  mutate_all(., as.numeric)

# replace non-missing values with 1 and missing values with 0
tmp[!is.na(tmp)] <- 1
tmp[is.na(tmp)] <- 0

# rowSum to get number of entries per participant
dtFull$numMsr <- rowSums(tmp)
table(dtFull$numMsr); rm(tmp)

```

## Continue cleaning
```{r}
# remove participants for long data with less than two measurements
dtFullRed <- dtFull %>%
  filter(numMsr > 2)
```

## Calculate relevant variables
### Baseline
#### Scales
```{r calcVars, echo=T, warning=F, message=F}
# positive emotion
  dtCtry %>% dplyr::select(affCalm, affContent, affEnerg, affInsp, affRel) %>% psych::describe()
  dtCtry$posEmo.m <- as.numeric(scoreItems(keys=c(1,1,1,1,1), # as.numeric is needed for Mplus later (does only take one-dimensional objects)
                            items = dtCtry %>% dplyr::select(affCalm, affContent, affEnerg, affInsp, affRel) %>% na_if(., -99),
                                min = 1, max = 5)$scores)
  dtCtry$posEmo.c <- as.numeric(scale(dtCtry$posEmo.m, scale = F, center = T))
  dtCtry$posEmo.z <- as.numeric(scale(dtCtry$posEmo.m, scale = T))
  dtCtry$posEmo.fa <- as.numeric(fa(dtCtry %>% dplyr::select(affCalm, affContent, affEnerg, affInsp, affRel))$scores)

# negative emotion
  dtCtry %>% dplyr::select(affAnx, affDepr, affNerv, affExh) %>% psych::describe()
  dtCtry$negEmo.m <- as.numeric(scoreItems(keys=c(1,1,1,1),
                            items = dtCtry %>% dplyr::select(affAnx, affDepr, affNerv, affExh) %>% na_if(., -99),
                                min = 1, max = 5)$scores)
  dtCtry$negEmo.c <- as.numeric(scale(dtCtry$negEmo.m, scale = F, center = T))
  dtCtry$negEmo.z <- as.numeric(scale(dtCtry$negEmo.m, scale = T))
  dtCtry$negEmo.fa <- as.numeric(fa(dtCtry %>% dplyr::select(affAnx, affDepr, affNerv, affExh))$scores)

# financial strain
  dtCtry %>% dplyr::select(PFS01, PFS02, PFS03) %>% psych::describe()
  dtCtry$PFS.m <- as.numeric(scoreItems(keys=c(1,1,1),
                            items = dtCtry %>% dplyr::select(PFS01, PFS02, PFS03) %>% na_if(., -99),
                                min = -2, max = 2)$scores)
  dtCtry$PFS.c <- as.numeric(scale(dtCtry$PFS.m, scale = F, center = T))
  dtCtry$PFS.z <- as.numeric(scale(dtCtry$PFS.m, scale = T))
  dtCtry$PFS.fa <- as.numeric(fa(dtCtry %>% dplyr::select(PFS01, PFS02, PFS03))$scores)
  
# disempowerment
  dtCtry %>% dplyr::select(fail01, fail02, fail03) %>% psych::describe()
  dtCtry$disemp.m <- as.numeric(scoreItems(keys=c(1,1,1),
                            items = dtCtry %>% dplyr::select(fail01, fail02, fail03) %>% na_if(., -99),
                                min = -2, max = 2)$scores)
  dtCtry$disemp.c <- as.numeric(scale(dtCtry$disemp.m, scale = F, center = T))
  dtCtry$disemp.z <- as.numeric(scale(dtCtry$disemp.m, scale = T))
  dtCtry$disemp.fa <- as.numeric(fa(dtCtry %>% dplyr::select(fail01, fail02, fail03))$scores)

# Well-Being
  # need rescaling first
    dtCtry$lifeSat <- scales::rescale(as.numeric(dtCtry$lifeSat), to = c(1,10))
    dtCtry$MLQ <- scales::rescale(as.numeric(dtCtry$MLQ), to = c(1,10))
  dtCtry %>% dplyr::select(happy, lifeSat, MLQ) %>% psych::describe()
  dtCtry$WB.m <- as.numeric(scoreItems(keys=c(1,1,1),
                                items = dtCtry %>% dplyr::select(happy, lifeSat, MLQ) %>% na_if(., -99),
                                min = 1, max = 10)$scores)
  dtCtry$WB.c <- as.numeric(scale(dtCtry$WB.m, scale = F, center = T))
  dtCtry$WB.z <- as.numeric(scale(dtCtry$WB.m, scale = T))
  dtCtry$WB.fa <- as.numeric(fa(dtCtry %>% dplyr::select(happy, lifeSat, MLQ))$scores)

# pro-Social Behavior
  dtCtry %>% dplyr::select(starts_with("c19ProSo"), -contains("DO")) %>% psych::describe()
  dtCtry$c19ProSo.m <- as.numeric(as.numeric(scoreItems(keys=c(1,1,1,1),
                                items = dtCtry %>% dplyr::select(starts_with("c19ProSo"), -contains("DO")) %>% na_if(., -99),
                                min = -3, max = 3)$scores))
  dtCtry$c19ProSo.c <- as.numeric(scale(dtCtry$c19ProSo.m, scale = F, center = T))
  dtCtry$c19ProSo.z <- as.numeric(scale(dtCtry$c19ProSo.m, scale = T))
  dtCtry$c19ProSo.fa <- as.numeric(fa(dtCtry %>% dplyr::select(starts_with("c19ProSo"), -contains("DO")))$scores)

```

#### Interactions
```{r calcInt, echo=T, warning=F, message=F}
# calculate interactions for observed modeling
  dtCtry <- dtCtry %>%
  mutate(intPosEmoXDisemp = posEmo.c*disemp.c,
         intNegEmoXDisemp = negEmo.c*disemp.c,
         intPFSXDisemp = PFS.c*disemp.c, scale = F, center = T)
```

### Within Participant
#### wide to long
```{r}
# select relevant vars
tmp <- dtFullRed %>%
  dplyr::transmute_at(vars(matches(
    paste(c("affAnx", "affCalm", "affDepr", "affEnerg", "affNerv", "affInsp", "affRel",
            "affExh", "PFS01", "happy", "lifeSat", "fail01", "c19ProSo03"), collapse = "|"), -contains("DO"))), #vars changed
    as.numeric)

# CLOSE YOUR EYES! TRIGGER WARNING! (should have named these variables better...)
tmp <- tmp %>%
  transmute(
    w00_affAnx = affAnx, w00_affCalm = affCalm, w00_affDepr = affDepr, w00_affEnerg = affEnerg, w00_affNerv = affNerv, 
    w00_affInsp = affInsp, w00_affRel = affRel, w00_affExh = affExh, w00_PFS01 = PFS01, w00_happy = happy, w00_lifeSat = lifeSat,
    w00_fail01 = fail01, w00_c19ProSo03 = c19ProSo03,
    w01_affAnx = w1_affAnx, w01_affCalm = w1_affCalm, w01_affDepr = w1_affDepr, w01_affEnerg = w1_affEnerg, 
    w01_affNerv = w1_affNerv, w01_affInsp = w1_affInsp, w01_affRel = w1_affRel, w01_affExh = w1_affExh, w01_PFS01 = w1_PFS01,
    w01_happy = NA_real_, w01_lifeSat = w1_lifeSat, w01_fail01 = w1_fail01, w01_c19ProSo03 = w1_c19ProSo03,
    w02_affAnx = w2_affAnx, w02_affCalm = w2_affCalm, w02_affDepr = w2_affDepr, w02_affEnerg = w2_affEnerg, 
    w02_affNerv = w2_affNerv, w02_affInsp = w2_affInsp, w02_affRel = w2_affRel, w02_affExh = w2_affExh, w02_PFS01 = w2_PFS01,
    w02_happy = NA_real_, w02_lifeSat = NA_real_, w02_fail01 = w2_fail01, w02_c19ProSo03 = w2_c19ProSo03,
    w03_affAnx = w3_affAnx, w03_affCalm = w3_affCalm, w03_affDepr = w3_affDepr, w03_affEnerg = w3_affEnerg, 
    w03_affNerv = w3_affNerv, w03_affInsp = w3_affInsp, w03_affRel = w3_affRel, w03_affExh = w3_affExh, w03_PFS01 = w3_PFS01,
    w03_happy = NA_real_, w03_lifeSat = NA_real_, w03_fail01 = w3_fail01, w03_c19ProSo03 = w3_c19ProSo03,
    w04_affAnx = w4_affAnx, w04_affCalm = w4_affCalm, w04_affDepr = w4_affDepr, w04_affEnerg = w4_affEnerg, 
    w04_affNerv = w4_affNerv, w04_affInsp = w4_affInsp, w04_affRel = w4_affRel, w04_affExh = w4_affExh, w04_PFS01 = w4_PFS01,
    w04_happy = w4_happy, w04_lifeSat = w4_lifeSat, w04_fail01 = w4_fail01, w04_c19ProSo03 = w4_c19ProSo03,
    w05_affAnx = w5_affAnx, w05_affCalm = w5_affCalm, w05_affDepr = w5_affDepr, w05_affEnerg = w5_affEnerg, 
    w05_affNerv = w5_affNerv, w05_affInsp = w5_affInsp, w05_affRel = w5_affRel, w05_affExh = w5_affExh, w05_PFS01 = w5_PFS01,
    w05_happy = w5_happy, w05_lifeSat = w5_lifeSat, w05_fail01 = w5_fail01, w05_c19ProSo03 = w5_c19ProSo03,
    w06_affAnx = w6_affAnx, w06_affCalm = w6_affCalm, w06_affDepr = w6_affDepr, w06_affEnerg = w6_affEnerg, 
    w06_affNerv = w6_affNerv, w06_affInsp = w6_affInsp, w06_affRel = w6_affRel, w06_affExh = w6_affExh, w06_PFS01 = NA_real_,
    w06_happy = NA_real_, w06_lifeSat = NA_real_, w06_fail01 = NA_real_, w06_c19ProSo03 = w6_c19ProSo03,
    w07_affAnx = w7_affAnx, w07_affCalm = w7_affCalm, w07_affDepr = w7_affDepr, w07_affEnerg = w7_affEnerg, 
    w07_affNerv = w7_affNerv, w07_affInsp = w7_affInsp, w07_affRel = w7_affRel, w07_affExh = w7_affExh, w07_PFS01 = NA_real_,
    w07_happy = NA_real_, w07_lifeSat = w7_lifeSat, w07_fail01 = NA_real_, w07_c19ProSo03 = w7_c19ProSo03,
    w08_affAnx = w8_affAnx, w08_affCalm = w8_affCalm, w08_affDepr = w8_affDepr, w08_affEnerg = w8_affEnerg, 
    w08_affNerv = w8_affNerv, w08_affInsp = w8_affInsp, w08_affRel = w8_affRel, w08_affExh = w8_affExh, w08_PFS01 = NA_real_,
    w08_happy = w8_happy, w08_lifeSat = NA_real_, w08_fail01 = NA_real_, w08_c19ProSo03 = w8_c19ProSo03,
    w09_affAnx = w9_affAnx, w09_affCalm = w9_affCalm, w09_affDepr = w9_affDepr, w09_affEnerg = w9_affEnerg, 
    w09_affNerv = w9_affNerv, w09_affInsp = w9_affInsp, w09_affRel = w9_affRel, w09_affExh = w9_affExh, w09_PFS01 = w9_PFS01,
    w09_happy = w9_happy, w09_lifeSat = NA_real_, w09_fail01 = w9_fail01, w09_c19ProSo03 = w9_c19ProSo03,
    w10_affAnx = w10_affAnx, w10_affCalm = w10_affCalm, w10_affDepr = w10_affDepr, w10_affEnerg = w10_affEnerg, 
    w10_affNerv = w10_affNerv, w10_affInsp = w10_affInsp, w10_affRel = w10_affRel, w10_affExh = w10_affExh, w10_PFS01 = NA_real_,
    w10_happy = NA_real_, w10_lifeSat = NA_real_, w10_fail01 = NA_real_, w10_c19ProSo03 = w10_c19ProSo03,
    w11_affAnx = w11_affAnx, w11_affCalm = w11_affCalm, w11_affDepr = w11_affDepr, w11_affEnerg = w11_affEnerg, 
    w11_affNerv = w11_affNerv, w11_affInsp = w11_affInsp, w11_affRel = w11_affRel, w11_affExh = w11_affExh, w11_PFS01 = w11_PFS01,
    w11_happy = w11_happy, w11_lifeSat = w11_lifeSat, w11_fail01 = w11_fail01, w11_c19ProSo03 = w11_c19ProSo03,
    w12_affAnx = w12_affAnx, w12_affCalm = w12_affCalm, w12_affDepr = w12_affDepr, w12_affEnerg = w12_affEnerg, 
    w12_affNerv = w12_affNerv, w12_affInsp = w12_affInsp, w12_affRel = w12_affRel, w12_affExh = w12_affExh, w12_PFS01 = w12_PFS01,
    w12_happy = w12_happy, w12_lifeSat = w12_lifeSat, w12_fail01 = w12_fail01, w12_c19ProSo03 = w12_c19ProSo03,
    w13_affAnx = w13_affAnx, w13_affCalm = w13_affCalm, w13_affDepr = w13_affDepr, w13_affEnerg = w13_affEnerg, 
    w13_affNerv = w13_affNerv, w13_affInsp = w13_affInsp, w13_affRel = w13_affRel, w13_affExh = w13_affExh, w13_PFS01 = w13_PFS01,
    w13_happy = w13_happy, w13_lifeSat = w13_lifeSat, w13_fail01 = w13_fail01, w13_c19ProSo03 = w13_c19ProSo03,
    w14_affAnx = w14_affAnx, w14_affCalm = w14_affCalm, w14_affDepr = w14_affDepr, w14_affEnerg = w14_affEnerg, 
    w14_affNerv = w14_affNerv, w14_affInsp = w14_affInsp, w14_affRel = w14_affRel, w14_affExh = w14_affExh, w14_PFS01 = w14_PFS01,
    w14_happy = w14_happy, w14_lifeSat = w14_lifeSat, w14_fail01 = w14_fail01, w14_c19ProSo03 = w14_c19ProSo03,
    w15_affAnx = w15_affAnx, w15_affCalm = w15_affCalm, w15_affDepr = w15_affDepr, w15_affEnerg = w15_affEnerg, 
    w15_affNerv = w15_affNerv, w15_affInsp = w15_affInsp, w15_affRel = w15_affRel, w15_affExh = w15_affExh, w15_PFS01 = w15_PFS01,
    w15_happy = w15_happy, w15_lifeSat = w15_lifeSat, w15_fail01 = w15_fail01, w15_c19ProSo03 = w15_c19ProSo03,
    w16_affAnx = w16_affAnx, w16_affCalm = w16_affCalm, w16_affDepr = w16_affDepr, w16_affEnerg = w16_affEnerg, 
    w16_affNerv = w16_affNerv, w16_affInsp = w16_affInsp, w16_affRel = w16_affRel, w16_affExh = w16_affExh, w16_PFS01 = w16_PFS01,
    w16_happy = w16_happy, w16_lifeSat = w16_lifeSat, w16_fail01 = w16_fail01, w16_c19ProSo03 = w16_c19ProSo03,
    w17_affAnx = w17_affAnx, w17_affCalm = w17_affCalm, w17_affDepr = w17_affDepr, w17_affEnerg = w17_affEnerg, 
    w17_affNerv = w17_affNerv, w17_affInsp = w17_affInsp, w17_affRel = w17_affRel, w17_affExh = w17_affExh, w17_PFS01 = w17_PFS01,
    w17_happy = w17_happy, w17_lifeSat = NA_real_, w17_fail01 = w17_fail01, w17_c19ProSo03 = w17_c19ProSo03,
    w18_affAnx = w18_affAnx, w18_affCalm = w18_affCalm, w18_affDepr = w18_affDepr, w18_affEnerg = w18_affEnerg, 
    w18_affNerv = w18_affNerv, w18_affInsp = w18_affInsp, w18_affRel = w18_affRel, w18_affExh = w18_affExh, w18_PFS01 = w18_PFS01,
    w18_happy = w18_happy, w18_lifeSat = NA_real_, w18_fail01 = w18_fail01, w18_c19ProSo03 = w18_c19ProSo03,
    w19_affAnx = w19_affAnx, w19_affCalm = w19_affCalm, w19_affDepr = w19_affDepr, w19_affEnerg = w19_affEnerg, 
    w19_affNerv = w19_affNerv, w19_affInsp = w19_affInsp, w19_affRel = w19_affRel, w19_affExh = w19_affExh, w19_PFS01 = w19_PFS01,
    w19_happy = w19_happy, w19_lifeSat = NA_real_, w19_fail01 = w19_fail01, w19_c19ProSo03 = w19_c19ProSo03,
    w20_affAnx = w20_affAnx, w20_affCalm = w20_affCalm, w20_affDepr = w20_affDepr, w20_affEnerg = w20_affEnerg, 
    w20_affNerv = w20_affNerv, w20_affInsp = w20_affInsp, w20_affRel = w20_affRel, w20_affExh = w20_affExh, w20_PFS01 = w20_PFS01,
    w20_happy = w20_happy, w20_lifeSat = w20_lifeSat, w20_fail01 = w20_fail01, w20_c19ProSo03 = w20_c19ProSo03,
    w21_affAnx = w21_affAnx, w21_affCalm = w21_affCalm, w21_affDepr = w21_affDepr, w21_affEnerg = w21_affEnerg, 
    w21_affNerv = w21_affNerv, w21_affInsp = w21_affInsp, w21_affRel = w21_affRel, w21_affExh = w21_affExh, w21_PFS01 = w21_PFS01,
    w21_happy = w21_happy, w21_lifeSat = w21_lifeSat, w21_fail01 = w21_fail01, w21_c19ProSo03 = w21_c19ProSo03,
    w22_affAnx = w22_affAnx, w22_affCalm = w22_affCalm, w22_affDepr = w22_affDepr, w22_affEnerg = w22_affEnerg, 
    w22_affNerv = w22_affNerv, w22_affInsp = w22_affInsp, w22_affRel = w22_affRel, w22_affExh = w22_affExh, w22_PFS01 = w22_PFS01,
    w22_happy = w22_happy, w22_lifeSat = w22_lifeSat, w22_fail01 = w22_fail01, w22_c19ProSo03 = w22_c19ProSo03
    )

tmp$PPID <- dtFullRed$PPID
tmp <- data.table::data.table(tmp)

library(data.table)
dtLong <- data.table::melt.data.table(
  data = tmp, 
  id.vars = "PPID",
  measure.vars = patterns( # cannot access patterns directly! need to load data.table library!!!
    affAnx = "affAnx",
    affCalm = "affCalm",
    affDepr = "affDepr",
    affEnerg = "affEnerg",
    affNerv = "affNerv",
    affInsp = "affInsp",
    affRel = "affRel",
    affExh = "affExh",
    PFS01 = "PFS01",
    happy = "happy",
    lifeSat = "lifeSat",
    fail01 = "fail01", 
    # c19ProSo01 = "c19ProSo01",
    c19ProSo03 = "c19ProSo03"),
  variable.name = "wave"
  )
rm(tmp)

# add non-longitudinal variables to dataset
tmp <- dtFullRed %>%
  select(PPID,
         coded_country)

dtLong <- dtLong %>%
  dplyr::left_join(tmp, by = "PPID"); rm(tmp)
```

#### Scales
```{r}

# input = dtLong
# waveNum = 2
# varNames = c("affAnx", "affDepr", "affNerv", "affExh")

# load function for averaging per wave
long_scale_calc <- function(input, waveNum, varNames) {
  
  input <- input %>%
  filter(wave == waveNum) %>%
  select(contains(varNames))

# check whether minimum is the same across input columns
  testMin = list()
  testMin$test <- input %>%
    summarise_each(funs(min(., na.rm = T)))%>%
    table()
  testMin$num <- input %>%
    summarise_each(funs(min(., na.rm = T))) %>%
    as.numeric()
  ifelse(ncol(testMin$test) & nrow(testMin$test) == 1, 
         print("All input variables have the same minimum"), 
         stop("Warning: Minimum seems to differ across input variables"))

# check whether maximum is the same across input columns
  testMax = list()
  testMax$test <- input %>%
    summarise_each(funs(max(., na.rm = T)))%>%
    table()
  testMax$num <- input %>%
    summarise_each(funs(max(., na.rm = T))) %>%
    as.numeric()
  ifelse(ncol(testMax$test) & nrow(testMax$test) == 1, 
         print("All input variables have the same maximum"), 
         stop("Warning: Maximum seems to differ across input variables"))
  
# calculate scale
  scaleCalc <- scoreItems(keys=rep(1, ncol(input)),
                          items = input,
                          min = testMin$num[1], max = testMax$num[1],
                          impute = "none")
  
  print(paste("Alpha for the following items in wave ", waveNum, ":", sep = ""))
  print(varNames)
  print(round(scaleCalc$alpha, 2))
  
  output <- round(as.numeric(scaleCalc$scores), 3)

  return(output)
  rm(testMin, testMax, scaleCalc, output, input)
}
```

##### calculate scales
```{r}
# ---------------- positive emotion-----------------
# create df for filling
  tmp <- data.table(matrix(NA, nrow = nrow(dtFullRed), ncol = 23))

# calculate scale per wave
  for (waveNum in 1:max(as.numeric(dtLong$wave))) {
    tmp[,waveNum] <- long_scale_calc(input = dtLong, waveNum = waveNum, varNames = c("affCalm", "affEnerg", "affInsp", "affRel"))
  }
  tmp$PPID <- dtFullRed$PPID

# turn into long format again
  tmp2 <- data.table::melt.data.table(
    data = tmp, 
    id.vars = "PPID",
    variable.name = "wave",
    value.name = "scale"
    )
# add to already existing dataframe of long data
  dtLong$posEmo <- as.numeric(tmp2$scale)
  rm(tmp, tmp2)

# ---------------- negative emotion-----------------
# create df for filling
  tmp <- data.table(matrix(NA, nrow = nrow(dtFullRed), ncol = 23))

# calculate scale per wave
  for (waveNum in 1:max(as.numeric(dtLong$wave))) {
    tmp[,waveNum] <- long_scale_calc(input = dtLong, waveNum = waveNum, varNames = c("affAnx", "affDepr", "affNerv", "affExh"))
  }
  tmp$PPID <- dtFullRed$PPID

# turn into long format again
  tmp2 <- data.table::melt.data.table(
    data = tmp, 
    id.vars = "PPID",
    variable.name = "wave",
    value.name = "scale"
    )
# add to already existing dataframe of long data
  dtLong$negEmo <- as.numeric(tmp2$scale)
  rm(tmp, tmp2)
  
dtLong[dtLong == "NaN"] <- NA
```

#### create centered variables (center within clsuter)
https://kzee.github.io/Centering_Demo.html (blml::isolate unfortunately does not work)
```{r}
# calculate mean and sds per participant
dtLong <- dtLong %>%
  group_by(PPID) %>%
  mutate(
    negEmo_mean = mean(negEmo, na.rm = T),
    negEmo_sd = sd(negEmo, na.rm = T),
    posEmo_mean = mean(posEmo, na.rm = T),
    posEmo_sd = sd(posEmo, na.rm = T),
    PFS01_mean = mean(PFS01, na.rm = T),
    PFS01_sd = sd(PFS01, na.rm = T),
    fail01_mean = mean(fail01, na.rm = T),
    fail01_sd = sd(fail01, na.rm = T),
    happy_mean = mean(happy, na.rm = T),
    happy_sd = sd(happy, na.rm = T),
    c19ProSo03_mean = mean(c19ProSo03, na.rm = T),
    c19ProSo03_sd = sd(c19ProSo03, na.rm = T),
  )

# center within (for grand mean centering or between-person centering see above link)
dtLong <- dtLong %>%
  ungroup() %>%
  mutate(
    negEmo_cw = negEmo-negEmo_mean,
    posEmo_cw = posEmo-posEmo_mean,
    disemp_cw = fail01-fail01_mean,
    PFS_cw = PFS01 - PFS01_mean,
    WB_cw = happy-happy_mean,
    c19ProSo_cw = c19ProSo03-c19ProSo03_mean
  )
```

# Analysis Longitudinal
http://www.alexanderdemos.org/Mixed5.html#plot_final_results_(fixed_effects_only)
```{r}
ana.0 <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana.0)
performance::icc(ana)
```

```{r}
ana.1 <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw + 
                    (1|coded_country) + 
                    (1+ PFS_cw|coded_country:PPID), # we can let slopes vary per participant (or by country if added in the line above)
                  data = dtLong)

summary(ana.1)
performance::icc(ana)
```

# Analysis Baseline
## MPlus Preparation
```{r}
 dtOut <- dtCtry %>%
  select(contains("c19ProSo"))

  prepareMplusData(dtOut[, 1:ncol(dtOut)], 
                   "test.dat")


```



## Confirmatory Factor Analysis
```{r explrFactor12}
  model <- 'level:1
            # Latent
            posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel 
            negEmo =~ affAnx + affDepr + affNerv + affExh
            PFS =~ PFS01 + PFS02 + PFS03
            disemp =~ fail01 + fail02 + fail03
            wellBe =~ happy + lifeSat + MLQ
            proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03
            level:2
            posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel
            negEmo =~ affAnx + affDepr + affNerv + affExh
            disemp =~ fail01 + fail02 + fail03
            PFS =~ PFS01 + PFS02 + PFS03
            wellBe =~ happy + lifeSat + MLQ
            proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03'
#fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em")
fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em", verbose = T, em.iter.max = 20000,
           em.fx.tol = 1e-08, em.dx.tol = 1e-04)
summary(fit, fit.measures=TRUE)
lavaanPlot::lavaanPlot(model = fit, coefs = T, covs = T)
```

<!-- ### MultiGroup Confirmatory Factor Analysis -->
<!-- ```{r explrFactor} -->
<!-- # by country all -->
<!--   fitGroup <- cfa(model, data = dtCtry, group = "coded_country") -->
<!--   summary(fitGroup, fit.measures=TRUE) -->

<!-- # by country constrained -->
<!--   #fitGroupConstr <- sem(model, dtCtry, group = "coded_country", group.equal = c("intercepts", "regressions")) -->

<!-- # compare unconstrained and constrained -->
<!--   #anova(fitGroup, fitGroupConstr) -->
<!-- ``` -->

## MultiLevel Approach
### posEmo - Well-Being with Fixed Slope
```{r}
tmp <- ggplot(dtCtry, aes(x = posEmo.m, y = WB.m)) +
  geom_point()+
  geom_smooth(method = 'lm')+
  theme_minimal()

ggExtra::ggMarginal(
  tmp, type = 'histogram', margins = 'both', size = 4, col = '#0F0101', fill = '#37AAE8'
)

# fit model with fixed slope
  mod1Fix <- lme4::lmer(WB.m ~ posEmo.c + (1|coded_country), data = dtCtry)
  summary(mod1Fix)
```

### posEmo - Well-Being with Random Slope
```{r}
tmp <- ggplot(dtCtry, aes(x = posEmo.m, y = WB.m, color = coded_country)) +
  geom_point()+
  geom_smooth(method = 'lm')+
  theme_minimal()
plotly::ggplotly(tmp)

# fit model with random slope
  mod1Rand <- lme4::lmer(WB.m ~ posEmo.c + (1 + posEmo.c|coded_country), data = dtCtry)
  anova(mod1Fix, mod1Rand) # test diff
  summary(mod1Rand)
  sjPlot::plot_model(mod1Rand, type = c("re"), show.values = T, value.offset = .5)

```

### Pro-Social - Well-Being with Fixed Slope
```{r}
tmp <- ggplot(dtCtry, aes(x = c19ProSo.m, y = WB.m)) +
  geom_point()+
  geom_smooth(method = 'lm')+
  theme_minimal()

ggExtra::ggMarginal(
  tmp, type = 'histogram', margins = 'both', size = 4, col = '#0F0101', fill = '#37AAE8'
)

# fit model with fixed slope
  mod2Fix <- lme4::lmer(WB.m ~ c19ProSo.c + (1|coded_country), data = dtCtry)
  summary(mod2Fix)
```

### ProSo - Well-Being with Random Slope
```{r}
tmp <- ggplot(dtCtry, aes(x = c19ProSo.m, y = WB.m, color = coded_country)) +
  geom_point()+
  geom_smooth(method = 'lm')+
  theme_minimal()
plotly::ggplotly(tmp)

# fit model with random slope
  mod2Rand <- lme4::lmer(WB.m ~ c19ProSo.c + (1 + c19ProSo.c|coded_country), data = dtCtry)
  anova(mod2Fix, mod2Rand) # test diff
  summary(mod2Rand)
  sjPlot::plot_model(mod2Rand, type =  c("re"), show.values = T, value.offset = .5)
```

### posEmo -ProSo - Well-Being with Fixed Slope
```{r}
# tmp <- ggplot(dtCtry, aes(x = c19ProSo.m, y = WB.m, color = coded_country)) +
#   geom_point()+
#   geom_smooth(method = 'lm')+
#   theme_minimal()
# plotly::ggplotly(tmp)

# fit model with random slope
  mod3Fix <- lme4::lmer(WB.m ~ c19ProSo.c + posEmo.c + (1|coded_country), data = dtCtry)
  summary(mod3Fix)
  sjPlot::plot_model(mod3Fix, type =  c("re"), show.values = T, value.offset = .5)
```

### posEmo -ProSo - Well-Being with Random Slope
```{r}
# tmp <- ggplot(dtCtry, aes(x = c19ProSo.m, y = WB.m, color = coded_country)) +
#   geom_point()+
#   geom_smooth(method = 'lm')+
#   theme_minimal()
# plotly::ggplotly(tmp)

# fit model with random slope
  mod3Rand <- lme4::lmer(WB.m ~ c19ProSo.c + posEmo.c + (1+ c19ProSo.c + posEmo.c |coded_country), data = dtCtry, REML = FALSE,  control = lme4::lmerControl(optimizer ="Nelder_Mead"))
  summary(mod3Rand)
  sjPlot::plot_model(mod3Rand, type =  c("re"), show.values = T, value.offset = .5)
```

### DV: Well-Being full model
```{r}
# fit model with random slope
  mod5Med <- lme4::lmer(WB.z ~ disemp.z*posEmo.z + disemp.z*negEmo.z + disemp.z*PFS.z + (1 |coded_country), data = dtCtry)
  mod5DV <- lme4::lmer(c19ProSo.m ~ WB.z + disemp.z*posEmo.z + disemp.z*negEmo.z + disemp.z*PFS.z + (1 |coded_country), data = dtCtry)
  summary(mod5Med)
  summary(mod5DV)
# mediation  
  anaMed <- mediation::mediate(mod5Med, mod5DV, treat='negEmo.z', mediator='WB.z', sims = 100)
  summary(anaMed)
# test for moderated mediation
  mediation::test.modmed(anaMed, list(disemp.z = -1), covariates.2 = list(disemp.z = 1), sims = 100)

# test for values at different levels of moderator 
  
  
  
  lattice::dotplot(ranef(mod5Rand, postVar=TRUE))
  
  

```

### Table: Multilevel Approach
```{r}
sjPlot::tab_model(mod1Fix, mod1Rand, mod2Fix, mod2Rand, mod3Fix, mod3Rand)
```


## Multilevel Path Modeling
### CFA: Check latent constructs
```{r}
  model <- 'level:1
            # Latent
            posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel 
            negEmo =~ affAnx + affDepr + affNerv + affExh
            PFS =~ PFS01 + PFS02 + PFS03
            disemp =~ fail01 + fail02 + fail03
            wellBe =~ happy + lifeSat + MLQ
            proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03
            level:2
            posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel
            negEmo =~ affAnx + affDepr + affNerv + affExh
            disemp =~ fail01 + fail02 + fail03
            PFS =~ PFS01 + PFS02 + PFS03
            wellBe =~ happy + lifeSat + MLQ
            proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03'
#fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em")
fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em", verbose = T, em.iter.max = 20000,
           em.fx.tol = 1e-08, em.dx.tol = 1e-04)
summary(fit, fit.measures=TRUE)
lavaanPlot::lavaanPlot(model = fit, coefs = T, covs = T)

```

### Well-Being as DV
We run a model in which the level 2 structure mirrors level 1. This means that on level 2 we model the intercepts (means) and one level 1 the values.
```{r}
# Explanation for below (from: https://www.youtube.com/watch?v=GZMXEq7GPvY):
# By adding the same model again on level 2, we are estimating the latent means now
  model <- 'level:1
            # a path
            WB.m ~ a1*posEmo.c + a2*negEmo.c + a3*PFS.c + a4*disemp.c + a5*intPosEmoXDisemp + a6*intNegEmoXDisemp + a7*intPFSXDisemp
            level:2
            # d path
            WB.m ~ d1*posEmo.c + d2*negEmo.c + d3*PFS.c + d4*disemp.c + d5*intPosEmoXDisemp + d6*intNegEmoXDisemp + d7*intPFSXDisemp'
fit <- sem(model, data = dtCtry, cluster = "coded_country")
# fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em", verbose = T, em.iter.max = 20000,
#            em.fx.tol = 1e-08, em.dx.tol = 1e-04)
summary(fit, fit.measures=TRUE)
lavInspect(fit, "icc")
```

### Pro-Sociality as DV
We run a model in which the level 2 structure mirrors level 1. This means that on level 2 we model the intercepts (means) and one level 1 the values.
```{r}
# Explanation for below (from: https://www.youtube.com/watch?v=GZMXEq7GPvY):
# By adding the same model again on level 2, we are estimating the latent means now
  model <- 'level:1
            # c path
            c19ProSo.m ~ c1*posEmo.c + c2*negEmo.c + c3*PFS.c + c4*disemp.c + c5*intPosEmoXDisemp + c6*intNegEmoXDisemp + c7*intPFSXDisemp
            # a path
            WB.m ~ a1*posEmo.c + a2*negEmo.c + a3*PFS.c + a4*disemp.c + a5*intPosEmoXDisemp + a6*intNegEmoXDisemp + a7*intPFSXDisemp
            # b path
            c19ProSo.m ~ b1*WB.m
            level:2
            # f path
            c19ProSo.m ~ f1*posEmo.c + f2*negEmo.c + f3*PFS.c + f4*disemp.c + f5*intPosEmoXDisemp + f6*intNegEmoXDisemp + f7*intPFSXDisemp
            # d path
            WB.m ~ d1*posEmo.c + d2*negEmo.c + d3*PFS.c + d4*disemp.c + d5*intPosEmoXDisemp + d6*intNegEmoXDisemp + d7*intPFSXDisemp
            # e path
            c19ProSo.m ~ e1*WB.m'
fit <- sem(model, data = dtCtry, cluster = "coded_country")
# fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em", verbose = T, em.iter.max = 20000,
#            em.fx.tol = 1e-08, em.dx.tol = 1e-04)
summary(fit, fit.measures=TRUE)
lavInspect(fit, "icc")
```

# OLD CODE: THIS IS REALLY COOL BUT DOES NOT WORK VERY WELL
## Multilevel SEM
### Mean Center all relevant vars
```{r}
# mean center the individual scales (this works but want to be sure)
  # dtCtry <- dtCtry %>%
  #   dplyr::mutate_at(vars(matches(
  #     paste(c("aff", "PFS", "fail", "happy", "lifeSat", "MLQ", "c19ProSo"), collapse = "|"), -contains("DO"))), #vars changed
  #     scale, center = T, scale = F) #function for change


# mean center "save" way
dtCtry <- dtCtry %>%
    mutate(affCalm = scale(affCalm, center = T, scale = F),
           affContent = scale(affContent, center = T, scale = F),
           affEnerg = scale(affEnerg, center = T, scale = F),
           affInsp = scale(affInsp, center = T, scale = F),
           affRel = scale(affRel, center = T, scale = F),
           affAnx = scale(affAnx, center = T, scale = F),
           affDepr = scale(affDepr, center = T, scale = F),
           affNerv = scale(affNerv, center = T, scale = F),
           affExh = scale(affExh, center = T, scale = F),
           PFS01 = scale(PFS01, center = T, scale = F),
           PFS02 = scale(PFS02, center = T, scale = F),
           PFS03 = scale(PFS03, center = T, scale = F),
           fail01 = scale(fail01, center = T, scale = F),
           fail02 = scale(fail02, center = T, scale = F),
           fail03 = scale(fail03, center = T, scale = F),
           happy = scale(happy, center = T, scale = F),
           lifeSat = scale(lifeSat, center = T, scale = F),
           MLQ = scale(MLQ, center = T, scale = F),
           c19ProSo01 = scale(c19ProSo01, center = T, scale = F),
           c19ProSo02 = scale(c19ProSo02, center = T, scale = F),
           c19ProSo03 = scale(c19ProSo03, center = T, scale = F),
           c19ProSo04 = scale(c19ProSo04, center = T, scale = F),
           )


# calculate interactions for the latent constructs
  dtCtry <- dtCtry %>%
    mutate(fail01XposEmo01 = scale(fail01*affCalm, center = T, scale = F),
           fail01XposEmo02 = scale(fail01*affContent, center = T, scale = F),
           fail01XposEmo03 = scale(fail01*affEnerg, center = T, scale = F),
           fail01XposEmo04 = scale(fail01*affInsp, center = T, scale = F),
           fail01XposEmo05 = scale(fail01*affRel, center = T, scale = F),
           fail02XposEmo01 = scale(fail02*affCalm, center = T, scale = F),
           fail02XposEmo02 = scale(fail02*affContent, center = T, scale = F),
           fail02XposEmo03 = scale(fail02*affEnerg, center = T, scale = F),
           fail02XposEmo04 = scale(fail02*affInsp, center = T, scale = F),
           fail02XposEmo05 = scale(fail02*affRel, center = T, scale = F),
           fail03XposEmo01 = scale(fail03*affCalm, center = T, scale = F),
           fail03XposEmo02 = scale(fail03*affContent, center = T, scale = F),
           fail03XposEmo03 = scale(fail03*affEnerg, center = T, scale = F),
           fail03XposEmo04 = scale(fail03*affInsp, center = T, scale = F),
           fail03XposEmo05 = scale(fail03*affRel, center = T, scale = F)
           )

  # calculate interactions for the latent constructs
  dtCtry <- dtCtry %>%
    mutate(fail01XposEmo01 = fail01*affCalm,
           fail01XposEmo02 = fail01*affContent,
           fail01XposEmo03 = fail01*affEnerg,
           fail01XposEmo04 = fail01*affInsp,
           fail01XposEmo05 = fail01*affRel,
           fail02XposEmo01 = fail02*affCalm,
           fail02XposEmo02 = fail02*affContent,
           fail02XposEmo03 = fail02*affEnerg,
           fail02XposEmo04 = fail02*affInsp,
           fail02XposEmo05 = fail02*affRel,
           fail03XposEmo01 = fail03*affCalm,
           fail03XposEmo02 = fail03*affContent,
           fail03XposEmo03 = fail03*affEnerg,
           fail03XposEmo04 = fail03*affInsp,
           fail03XposEmo05 = fail03*affRel
           )
```


### posEmo - WB - proSo 
#### Normal SEM
```{r}
model <- '# Model 
            posEmo  =~ affCalm + affContent + affEnerg + affInsp + affRel 
            WB =~ happy + lifeSat + MLQ
            c19ProSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03 + c19ProSo04
          # Regression
            c19ProSo ~ a*posEmo
            WB ~ b*c19ProSo + c*posEmo'
fit <- sem(model, data = dtCtry)
summary(fit, fit.measures=TRUE)
lavaanPlot::lavaanPlot(model = fit, coefs = T, covs = T)


```

#### Multilevel SEM Model 1-1-1
First we run a model that has no specified level 2 (only covariances)
```{r}
# Explanation for below (from: https://www.youtube.com/watch?v=GZMXEq7GPvY):
# By adding the same model again on level 2, we are estimating the latent means now
# saturated model on level 2
  model <- 'level:1
            c19ProSo.c ~ a*posEmo.c
            WB.m ~ b*c19ProSo.c + c*posEmo.c
            level:2
            c19ProSo.c ~~ posEmo.c
            c19ProSo.c ~~ WB.m
            WB.m ~~ posEmo.c
            # Indirect effects
            ab:=a*b
            total:=ab+c'
fit <- sem(model, data = dtCtry, cluster = "coded_country")
summary(fit, fit.measures=TRUE)
```

Next we run a model that also has no level 2 specified (only intercepts)
```{r}
# level 2 only intercepts
  model <- 'level:1
            c19ProSo.c ~ a*posEmo.c
            WB.m ~ b*c19ProSo.c + c*posEmo.c
            level:2
            c19ProSo.c ~ 1
            posEmo.c ~1
            WB.m ~ 1
            # Indirect effects
            ab:=a*b
            total:=ab+c'
fit <- sem(model, data = dtCtry, cluster = "coded_country")
summary(fit, fit.measures=TRUE)
```

Finally we run a model in which the level 2 structure mirrors level 1. This means that on level 2 we model the intercepts (means) and one level 1 the values.
```{r}
# specified model
model <- 'level:1
          c19ProSo.c ~ a*posEmo.c
          WB.m ~ b*c19ProSo.c + c*posEmo.c
          level:2
          c19ProSo.c ~ d*posEmo.c
          WB.m ~ e*c19ProSo.c + f*posEmo.c
          # Indirect and total effects within
          ab:=a*b
          totalwith:=ab+c 
          # Indirect and total effects between
          de:=d*e
          totalbw:=de+f' 
fit <- sem(model, data = dtCtry, cluster = "coded_country")
summary(fit, fit.measures=TRUE)
lavInspect(fit, "icc")
```

### predictors - WB  
#### Multilevel SEM (latent vars)
##### First: Measurement model
We run a model in which the level 2 structure mirrors level 1. This means that on level 2 we model the intercepts (means) and one level 1 the values.
In this first step, we test the measurement model to see whether the constructs even fit. Fit indeces seem adequate.
```{r}
# Explanation for below (from: https://www.youtube.com/watch?v=GZMXEq7GPvY):
# By adding the same model again on level 2, we are estimating the latent means now
  model <- 'level:1
            # Latent
            posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel 
            negEmo =~ affAnx + affDepr + affNerv + affExh
            PFS =~ PFS01 + PFS02 + PFS03
            disemp =~ fail01 + fail02 + fail03
            wellBe =~ happy + lifeSat + MLQ
            proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03
            level:2
            posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel
            negEmo =~ affAnx + affDepr + affNerv + affExh
            disemp =~ fail01 + fail02 + fail03
            PFS =~ PFS01 + PFS02 + PFS03
            wellBe =~ happy + lifeSat + MLQ
            proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03'
fit <- sem(model, data = dtCtry, cluster = "coded_country")
fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em", verbose = T, em.iter.max = 20000, em.fx.tol = 1e-08, em.dx.tol = 1e-04)
summary(fit, fit.measures=TRUE)
lavaanPlot::lavaanPlot(model = fit, coefs = T, covs = T)

```

##### Second: Regression Model
```{r}
  model <- 'level:1
          # Latent IVs
            posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel 
            negEmo =~ affAnx + affDepr + affNerv + affExh
            PFS =~ PFS01 + PFS02 + PFS03
            disemp =~ fail01 + fail02 + fail03
          # Latent Mediator
            wellBe =~ happy + lifeSat + MLQ
          # Latent DV
            proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03
          # Regression
            wellBe ~ a1*posEmo + a2*negEmo + a3*PFS + a4*disemp
            level:2
          # Latent
            posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel
            negEmo =~ affAnx + affDepr + affNerv + affExh
            disemp =~ fail01 + fail02 + fail03
            PFS =~ PFS01 + PFS02 + PFS03
            wellBe =~ happy + lifeSat + MLQ
            proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03
          # Regression
            wellBe ~ d1*posEmo + d2*negEmo + d3*PFS + d4*disemp'
#fit <- sem(model, data = dtCtry, cluster = "coded_country")
fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em", verbose = T, em.iter.max = 20000,
           em.fx.tol = 1e-08, em.dx.tol = 1e-04)
lavaanPlot::lavaanPlot(model = fit, coefs = T, covs = T)
```

##### Third: Interaction Model
```{r}
  model <- 'level:1
          # Latent Constructs
            posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel 
            negEmo =~ affAnx + affDepr + affNerv + affExh
            PFS =~ PFS01 + PFS02 + PFS03
            disemp =~ fail01 + fail02 + fail03
            wellBe =~ happy + lifeSat + MLQ
            proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03
          # Interactions
            failXposEmo =~ fail01XposEmo01 + fail01XposEmo02 + fail01XposEmo03 + fail01XposEmo04 + fail01XposEmo05 + fail02XposEmo01 + fail02XposEmo02 + fail02XposEmo03 + fail02XposEmo04 + fail02XposEmo05 + fail03XposEmo01 + fail03XposEmo02 + fail03XposEmo03 + fail03XposEmo04 + fail03XposEmo05
          # Regression
            wellBe ~ a1*posEmo + a2*negEmo + a3*PFS + a4*disemp + a5*failXposEmo
            level:2
          # Latent Constructs
            posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel
            negEmo =~ affAnx + affDepr + affNerv + affExh
            disemp =~ fail01 + fail02 + fail03
            PFS =~ PFS01 + PFS02 + PFS03
            wellBe =~ happy + lifeSat + MLQ
            proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03
          # Interactions
            failXposEmo =~ fail01XposEmo01 + fail01XposEmo02 + fail01XposEmo03 + fail01XposEmo04 + fail01XposEmo05 + fail02XposEmo01 + fail02XposEmo02 + fail02XposEmo03 + fail02XposEmo04 + fail02XposEmo05 + fail03XposEmo01 + fail03XposEmo02 + fail03XposEmo03 + fail03XposEmo04 + fail03XposEmo05
          # Regression
            wellBe ~ d1*posEmo + d2*negEmo + d3*PFS + d4*disemp + d6*failXposEmo'

fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em", verbose = T, em.iter.max = 20000, em.fx.tol = 1e-08, em.dx.tol = 1e-04)
summary(fit, fit.measures=TRUE)
 lavaanPlot::lavaanPlot(model = fit, coefs = T, covs = T)
 
# semTools::plotProbe (probe a latent interaction) https://rdrr.io/cran/semTools/man/plotProbe.html
 
```

## Longitudinal
```{r}

# use growth() from lavaan package with cluster
```

