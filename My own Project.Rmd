---
title: "PsyCorona"
author: "Maximilian Agostini"
date: "May 2020"
output:
  html_document:
    code_folding: hide
    mathjax: default
    theme: united
    toc: yes
    toc_float: yes
    number_sections: TRUE
  pdf_document:
    toc: yes
---

<style type="text/css">
.main-container {
  max-width: 1200px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r setup, include=FALSE}
cat("\014") # clear console
rm(list=ls()) # clear workspace
gc # garbage collector

require(pacman)
p_load(metafor, tidyr, dplyr, tinytex, knitr, kableExtra, DescTools, reshape2, metaSEM, lavaan, semPlot, psych, ggplot2, MplusAutomation, bmlm)

set.seed(52) # set overall random seed for reproducibility

# function to calculate indirect effects
calc_indirect_effect <- function(nameIn, pathA, pathB, varA, varB, covAB, rep, conf) {
   pest=c(pathA,pathB)
   acov <- matrix(c(varA, covAB,covAB, varB),2,2)
   mcmc <- MASS::mvrnorm(rep,pest,acov,empirical=FALSE)
  ab <- mcmc[,1]*mcmc[,2]
  low=(1-conf/100)/2
  upp=((1-conf/100)/2)+(conf/100)
  LL=quantile(ab,low)
  UL=quantile(ab,upp)
  LL4=format(LL,digits=4)
  UL4=format(UL,digits=4)
  hist(ab,breaks='FD',col='skyblue',xlab=paste(conf,'% Confidence Interval ','LL',LL4,'  UL',UL4),
  main='Distribution of Indirect Effect')
  
  # get lower and upper bound
  out <- data.frame(nameIn = as.character(nameIn), LL = round(LL, 3), UL = round(UL, 3))
  return(out)
}

# function to get summary statistics for MLM
mlm_summary_out <- function(model) {
   
  CI = lme4::confint.merMod(model, method = "boot", nsim = 500) # increase to 500 for serious run! 
 
   dt <- data.frame(B = lme4::fixef(model),
      SE = summary(model)$coefficients[,2],
      p = parameters::p_value(model)$p,
      CI_low_boots = CI[which(rownames(CI) == "(Intercept)"):nrow(CI),1], # need to make this dynamic because size changes depending on number of levels in mlm
      CI_high_boots = CI[which(rownames(CI) == "(Intercept)") :nrow(CI),2],
      CI_low = lme4::fixef(model)-1.96*summary(model)$coefficients[,2],
      CI_up = lme4::fixef(model)+1.96*summary(model)$coefficients[,2])%>%
  round(., 3)
   return(dt)
}
```

# Load Data
```{r LoadRawBase, echo=T, warning=F, message=F}
# Import Data
dtRaw <- haven::read_spss(dir("data", pattern = "Agostini", full.names = TRUE, ignore.case = TRUE))
```

# Prepare Data
## Cleaning
```{r clean, echo=T, warning=F, message=F}
# change all -99 into NA
  dtRaw[dtRaw == -99] <- NA

# add running number as pp
  dtRaw$PPID <- c(1:nrow(dtRaw))

# make relevant dfs
dtFull <- dtRaw

# make relevant vars numeric
dtFull <- dtFull %>%
  dplyr::mutate_at(vars(matches(
    paste(c("aff", "PFS", "fail", "happy", "lifeSat", "MLQ", "c19ProSo"), collapse = "|"), -contains("DO"))), #vars changed
    as.numeric) #function for change

# create between subjects baseline df
dtCross <- dtRaw %>% 
  group_by(coded_country) %>% # group by country
  filter(n() > 20) # remove countries with less than 20 people
dtCross <- dtCross %>% #needs to be ungrouped for the scale calculation
  ungroup()
table(dtCross$coded_country)
rm(dtRaw)
```

### Calc relevant stats
```{r}
# calculate number of measurement points (based on hope variable as most people answered it)
tmp <- dtFull %>%
  select(contains("c19Hope"),
         -contains("DO"))%>%
  mutate_all(., as.numeric)

# replace non-missing values with 1 and missing values with 0
tmp[!is.na(tmp)] <- 1
tmp[is.na(tmp)] <- 0

# rowSum to get number of entries per participant
dtFull$numMsr <- rowSums(tmp)
table(dtFull$numMsr); rm(tmp)

```

## Continue cleaning
```{r}
# remove participants for long data with less than two measurements
dtFullRed <- dtFull %>%
  filter(numMsr > 2) # could be handy but not really solves a problem (data over time argument)

# remove countries with less than 20 people
table(dtFullRed$coded_country)

dtFullRed <- dtFullRed %>% 
  group_by(coded_country) %>% # group by country
  filter(n() > 20) # remove countries with less than 100 people
dtFullRed <- dtFullRed %>% #needs to be ungrouped for the scale calculation
  ungroup()
table(dtFullRed$coded_country)

```

## Calculate relevant variables
### Cross-Sectional/Baseline
#### Scales
##### Multigroup CFA
```{r explrFactor12}
  model <- 'level:1
            # Latent
            posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel
            negEmo =~ affAnx + affDepr + affNerv + affExh
            PFS =~ PFS01 + PFS02 + PFS03
            disemp =~ fail01 + fail02 + fail03
            wellBe =~ happy + lifeSat + MLQ
            proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03
            level:2
            posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel
            negEmo =~ affAnx + affDepr + affNerv + affExh
            disemp =~ fail01 + fail02 + fail03
            PFS =~ PFS01 + PFS02 + PFS03
            wellBe =~ happy + lifeSat + MLQ
            proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03'
#fit <- sem(model, data = dtCross, cluster = "coded_country", optim.method = "em")
fit <- sem(model, data = dtCross, cluster = "coded_country", optim.method = "em", verbose = T, em.iter.max = 20000,
           em.fx.tol = 1e-08, em.dx.tol = 1e-04)
summary(fit, fit.measures=TRUE)
lavaanPlot::lavaanPlot(model = fit, coefs = T, covs = T)
```

##### calculate scales
```{r calcVars, echo=T, warning=F, message=F}
# positive emotion
  dtCross %>% dplyr::select(affCalm, affContent, affEnerg, affInsp, affRel) %>% psych::describe()
  dtCross$posEmo<- as.numeric(scoreItems(keys=c(1,1,1,1,1), # as.numeric is needed for Mplus later (does only take one-dimensional objects)
                            items = dtCross %>% dplyr::select(affCalm, affContent, affEnerg, affInsp, affRel) %>% na_if(., -99),
                                min = 1, max = 5)$scores)

# negative emotion
  dtCross %>% dplyr::select(affAnx, affDepr, affNerv, affExh) %>% psych::describe()
  dtCross$negEmo <- as.numeric(scoreItems(keys=c(1,1,1,1),
                            items = dtCross %>% dplyr::select(affAnx, affDepr, affNerv, affExh) %>% na_if(., -99),
                                min = 1, max = 5)$scores)

# financial strain
  dtCross %>% dplyr::select(PFS01, PFS02, PFS03) %>% psych::describe()
  dtCross$PFS <- as.numeric(scoreItems(keys=c(1,1,1),
                            items = dtCross %>% dplyr::select(PFS01, PFS02, PFS03) %>% na_if(., -99),
                                min = -2, max = 2)$scores)

# disempowerment
  dtCross %>% dplyr::select(fail01, fail02, fail03) %>% psych::describe()
  dtCross$disemp <- as.numeric(scoreItems(keys=c(1,1,1),
                            items = dtCross %>% dplyr::select(fail01, fail02, fail03) %>% na_if(., -99),
                                min = -2, max = 2)$scores)

# Well-Being
  # need rescaling first
    dtCross$lifeSat <- scales::rescale(as.numeric(dtCross$lifeSat), to = c(1,10))
    dtCross$MLQ <- scales::rescale(as.numeric(dtCross$MLQ), to = c(1,10))
  dtCross %>% dplyr::select(happy, lifeSat, MLQ) %>% psych::describe()
  dtCross$WB <- as.numeric(scoreItems(keys=c(1,1,1),
                                items = dtCross %>% dplyr::select(happy, lifeSat, MLQ) %>% na_if(., -99),
                                min = 1, max = 10)$scores)

# pro-Social Behavior
  dtCross %>% dplyr::select(starts_with("c19ProSo"), -contains("DO")) %>% psych::describe()
  dtCross$c19ProSo <- as.numeric(as.numeric(scoreItems(keys=c(1,1,1,1),
                                items = dtCross %>% dplyr::select(starts_with("c19ProSo"), -contains("DO")) %>% na_if(., -99),
                                min = -3, max = 3)$scores))

```

##### center scales
```{r}
# calculate mean and sds per country
dtCross <- dtCross %>%
  group_by(coded_country) %>%
  mutate(
    negEmoCountry_mean = mean(negEmo, na.rm = T),
    posEmoCountry_mean = mean(posEmo, na.rm = T),
    PFSCountry_mean = mean(PFS, na.rm = T),
    disempCountry_mean = mean(disemp, na.rm = T),
    WBCountry_mean = mean(WB, na.rm = T),
    c19ProSoCountry_mean = mean(c19ProSo, na.rm = T),
  ) %>%
  ungroup()

# group mean centering
dtCross <- dtCross %>%
  ungroup() %>%
  mutate(
    negEmo_cw = negEmo-negEmoCountry_mean,
    posEmo_cw = posEmo-posEmoCountry_mean,
    disemp_cw = disemp-disempCountry_mean,
    PFS_cw = PFS - PFSCountry_mean,
    WB_cw = WB-WBCountry_mean,
    negEmoCtry_cw = negEmoCountry_mean-mean(negEmoCountry_mean, na.rm = T),
    posEmoCtry_cw = posEmoCountry_mean-mean(posEmoCountry_mean, na.rm = T),
    disempCtry_cw = disempCountry_mean-mean(disempCountry_mean, na.rm = T),
    PFSCtry_cw =  PFSCountry_mean-mean(PFSCountry_mean, na.rm = T),
    WBCtry_cw = WBCountry_mean-mean(WBCountry_mean, na.rm = T)
  )
```

### Longitudinal
#### wide to long
```{r}
# select relevant vars
tmp <- dtFullRed %>%
  dplyr::transmute_at(vars(matches(
    paste(c("affAnx", "affCalm", "affDepr", "affEnerg", "affNerv", "affInsp", "affRel",
            "affExh", "PFS01", "happy", "lifeSat", "fail01", "c19ProSo03"), collapse = "|"), -contains("DO"))), #vars changed
    as.numeric)

# CLOSE YOUR EYES! TRIGGER WARNING! (should have named these variables better...)
tmp <- tmp %>%
  transmute(
    w00_affAnx = affAnx, w00_affCalm = affCalm, w00_affDepr = affDepr, w00_affEnerg = affEnerg, w00_affNerv = affNerv, 
    w00_affInsp = affInsp, w00_affRel = affRel, w00_affExh = affExh, w00_PFS01 = PFS01, w00_happy = happy, w00_lifeSat = lifeSat,
    w00_fail01 = fail01, w00_c19ProSo03 = c19ProSo03,
    w01_affAnx = w1_affAnx, w01_affCalm = w1_affCalm, w01_affDepr = w1_affDepr, w01_affEnerg = w1_affEnerg, 
    w01_affNerv = w1_affNerv, w01_affInsp = w1_affInsp, w01_affRel = w1_affRel, w01_affExh = w1_affExh, w01_PFS01 = w1_PFS01,
    w01_happy = NA_real_, w01_lifeSat = w1_lifeSat, w01_fail01 = w1_fail01, w01_c19ProSo03 = w1_c19ProSo03,
    w02_affAnx = w2_affAnx, w02_affCalm = w2_affCalm, w02_affDepr = w2_affDepr, w02_affEnerg = w2_affEnerg, 
    w02_affNerv = w2_affNerv, w02_affInsp = w2_affInsp, w02_affRel = w2_affRel, w02_affExh = w2_affExh, w02_PFS01 = w2_PFS01,
    w02_happy = NA_real_, w02_lifeSat = NA_real_, w02_fail01 = w2_fail01, w02_c19ProSo03 = w2_c19ProSo03,
    w03_affAnx = w3_affAnx, w03_affCalm = w3_affCalm, w03_affDepr = w3_affDepr, w03_affEnerg = w3_affEnerg, 
    w03_affNerv = w3_affNerv, w03_affInsp = w3_affInsp, w03_affRel = w3_affRel, w03_affExh = w3_affExh, w03_PFS01 = w3_PFS01,
    w03_happy = NA_real_, w03_lifeSat = NA_real_, w03_fail01 = w3_fail01, w03_c19ProSo03 = w3_c19ProSo03,
    w04_affAnx = w4_affAnx, w04_affCalm = w4_affCalm, w04_affDepr = w4_affDepr, w04_affEnerg = w4_affEnerg, 
    w04_affNerv = w4_affNerv, w04_affInsp = w4_affInsp, w04_affRel = w4_affRel, w04_affExh = w4_affExh, w04_PFS01 = w4_PFS01,
    w04_happy = w4_happy, w04_lifeSat = w4_lifeSat, w04_fail01 = w4_fail01, w04_c19ProSo03 = w4_c19ProSo03,
    w05_affAnx = w5_affAnx, w05_affCalm = w5_affCalm, w05_affDepr = w5_affDepr, w05_affEnerg = w5_affEnerg, 
    w05_affNerv = w5_affNerv, w05_affInsp = w5_affInsp, w05_affRel = w5_affRel, w05_affExh = w5_affExh, w05_PFS01 = w5_PFS01,
    w05_happy = w5_happy, w05_lifeSat = w5_lifeSat, w05_fail01 = w5_fail01, w05_c19ProSo03 = w5_c19ProSo03,
    w06_affAnx = w6_affAnx, w06_affCalm = w6_affCalm, w06_affDepr = w6_affDepr, w06_affEnerg = w6_affEnerg, 
    w06_affNerv = w6_affNerv, w06_affInsp = w6_affInsp, w06_affRel = w6_affRel, w06_affExh = w6_affExh, w06_PFS01 = NA_real_,
    w06_happy = NA_real_, w06_lifeSat = NA_real_, w06_fail01 = NA_real_, w06_c19ProSo03 = w6_c19ProSo03,
    w07_affAnx = w7_affAnx, w07_affCalm = w7_affCalm, w07_affDepr = w7_affDepr, w07_affEnerg = w7_affEnerg, 
    w07_affNerv = w7_affNerv, w07_affInsp = w7_affInsp, w07_affRel = w7_affRel, w07_affExh = w7_affExh, w07_PFS01 = NA_real_,
    w07_happy = NA_real_, w07_lifeSat = w7_lifeSat, w07_fail01 = NA_real_, w07_c19ProSo03 = w7_c19ProSo03,
    w08_affAnx = w8_affAnx, w08_affCalm = w8_affCalm, w08_affDepr = w8_affDepr, w08_affEnerg = w8_affEnerg, 
    w08_affNerv = w8_affNerv, w08_affInsp = w8_affInsp, w08_affRel = w8_affRel, w08_affExh = w8_affExh, w08_PFS01 = NA_real_,
    w08_happy = w8_happy, w08_lifeSat = NA_real_, w08_fail01 = NA_real_, w08_c19ProSo03 = w8_c19ProSo03,
    w09_affAnx = w9_affAnx, w09_affCalm = w9_affCalm, w09_affDepr = w9_affDepr, w09_affEnerg = w9_affEnerg, 
    w09_affNerv = w9_affNerv, w09_affInsp = w9_affInsp, w09_affRel = w9_affRel, w09_affExh = w9_affExh, w09_PFS01 = w9_PFS01,
    w09_happy = w9_happy, w09_lifeSat = NA_real_, w09_fail01 = w9_fail01, w09_c19ProSo03 = w9_c19ProSo03,
    w10_affAnx = w10_affAnx, w10_affCalm = w10_affCalm, w10_affDepr = w10_affDepr, w10_affEnerg = w10_affEnerg, 
    w10_affNerv = w10_affNerv, w10_affInsp = w10_affInsp, w10_affRel = w10_affRel, w10_affExh = w10_affExh, w10_PFS01 = NA_real_,
    w10_happy = NA_real_, w10_lifeSat = NA_real_, w10_fail01 = NA_real_, w10_c19ProSo03 = w10_c19ProSo03,
    w11_affAnx = w11_affAnx, w11_affCalm = w11_affCalm, w11_affDepr = w11_affDepr, w11_affEnerg = w11_affEnerg, 
    w11_affNerv = w11_affNerv, w11_affInsp = w11_affInsp, w11_affRel = w11_affRel, w11_affExh = w11_affExh, w11_PFS01 = w11_PFS01,
    w11_happy = w11_happy, w11_lifeSat = w11_lifeSat, w11_fail01 = w11_fail01, w11_c19ProSo03 = w11_c19ProSo03,
    w12_affAnx = w12_affAnx, w12_affCalm = w12_affCalm, w12_affDepr = w12_affDepr, w12_affEnerg = w12_affEnerg, 
    w12_affNerv = w12_affNerv, w12_affInsp = w12_affInsp, w12_affRel = w12_affRel, w12_affExh = w12_affExh, w12_PFS01 = w12_PFS01,
    w12_happy = w12_happy, w12_lifeSat = w12_lifeSat, w12_fail01 = w12_fail01, w12_c19ProSo03 = w12_c19ProSo03,
    w13_affAnx = w13_affAnx, w13_affCalm = w13_affCalm, w13_affDepr = w13_affDepr, w13_affEnerg = w13_affEnerg, 
    w13_affNerv = w13_affNerv, w13_affInsp = w13_affInsp, w13_affRel = w13_affRel, w13_affExh = w13_affExh, w13_PFS01 = w13_PFS01,
    w13_happy = w13_happy, w13_lifeSat = w13_lifeSat, w13_fail01 = w13_fail01, w13_c19ProSo03 = w13_c19ProSo03,
    w14_affAnx = w14_affAnx, w14_affCalm = w14_affCalm, w14_affDepr = w14_affDepr, w14_affEnerg = w14_affEnerg, 
    w14_affNerv = w14_affNerv, w14_affInsp = w14_affInsp, w14_affRel = w14_affRel, w14_affExh = w14_affExh, w14_PFS01 = w14_PFS01,
    w14_happy = w14_happy, w14_lifeSat = w14_lifeSat, w14_fail01 = w14_fail01, w14_c19ProSo03 = w14_c19ProSo03,
    w15_affAnx = w15_affAnx, w15_affCalm = w15_affCalm, w15_affDepr = w15_affDepr, w15_affEnerg = w15_affEnerg, 
    w15_affNerv = w15_affNerv, w15_affInsp = w15_affInsp, w15_affRel = w15_affRel, w15_affExh = w15_affExh, w15_PFS01 = w15_PFS01,
    w15_happy = w15_happy, w15_lifeSat = w15_lifeSat, w15_fail01 = w15_fail01, w15_c19ProSo03 = w15_c19ProSo03,
    w16_affAnx = w16_affAnx, w16_affCalm = w16_affCalm, w16_affDepr = w16_affDepr, w16_affEnerg = w16_affEnerg, 
    w16_affNerv = w16_affNerv, w16_affInsp = w16_affInsp, w16_affRel = w16_affRel, w16_affExh = w16_affExh, w16_PFS01 = w16_PFS01,
    w16_happy = w16_happy, w16_lifeSat = w16_lifeSat, w16_fail01 = w16_fail01, w16_c19ProSo03 = w16_c19ProSo03,
    w17_affAnx = w17_affAnx, w17_affCalm = w17_affCalm, w17_affDepr = w17_affDepr, w17_affEnerg = w17_affEnerg, 
    w17_affNerv = w17_affNerv, w17_affInsp = w17_affInsp, w17_affRel = w17_affRel, w17_affExh = w17_affExh, w17_PFS01 = w17_PFS01,
    w17_happy = w17_happy, w17_lifeSat = NA_real_, w17_fail01 = w17_fail01, w17_c19ProSo03 = w17_c19ProSo03,
    w18_affAnx = w18_affAnx, w18_affCalm = w18_affCalm, w18_affDepr = w18_affDepr, w18_affEnerg = w18_affEnerg, 
    w18_affNerv = w18_affNerv, w18_affInsp = w18_affInsp, w18_affRel = w18_affRel, w18_affExh = w18_affExh, w18_PFS01 = w18_PFS01,
    w18_happy = w18_happy, w18_lifeSat = NA_real_, w18_fail01 = w18_fail01, w18_c19ProSo03 = w18_c19ProSo03,
    w19_affAnx = w19_affAnx, w19_affCalm = w19_affCalm, w19_affDepr = w19_affDepr, w19_affEnerg = w19_affEnerg, 
    w19_affNerv = w19_affNerv, w19_affInsp = w19_affInsp, w19_affRel = w19_affRel, w19_affExh = w19_affExh, w19_PFS01 = w19_PFS01,
    w19_happy = w19_happy, w19_lifeSat = NA_real_, w19_fail01 = w19_fail01, w19_c19ProSo03 = w19_c19ProSo03,
    w20_affAnx = w20_affAnx, w20_affCalm = w20_affCalm, w20_affDepr = w20_affDepr, w20_affEnerg = w20_affEnerg, 
    w20_affNerv = w20_affNerv, w20_affInsp = w20_affInsp, w20_affRel = w20_affRel, w20_affExh = w20_affExh, w20_PFS01 = w20_PFS01,
    w20_happy = w20_happy, w20_lifeSat = w20_lifeSat, w20_fail01 = w20_fail01, w20_c19ProSo03 = w20_c19ProSo03,
    w21_affAnx = w21_affAnx, w21_affCalm = w21_affCalm, w21_affDepr = w21_affDepr, w21_affEnerg = w21_affEnerg, 
    w21_affNerv = w21_affNerv, w21_affInsp = w21_affInsp, w21_affRel = w21_affRel, w21_affExh = w21_affExh, w21_PFS01 = w21_PFS01,
    w21_happy = w21_happy, w21_lifeSat = w21_lifeSat, w21_fail01 = w21_fail01, w21_c19ProSo03 = w21_c19ProSo03,
    w22_affAnx = w22_affAnx, w22_affCalm = w22_affCalm, w22_affDepr = w22_affDepr, w22_affEnerg = w22_affEnerg, 
    w22_affNerv = w22_affNerv, w22_affInsp = w22_affInsp, w22_affRel = w22_affRel, w22_affExh = w22_affExh, w22_PFS01 = w22_PFS01,
    w22_happy = w22_happy, w22_lifeSat = w22_lifeSat, w22_fail01 = w22_fail01, w22_c19ProSo03 = w22_c19ProSo03
    )

tmp$PPID <- dtFullRed$PPID
tmp <- data.table::data.table(tmp)

library(data.table)
dtLong <- data.table::melt.data.table(
  data = tmp, 
  id.vars = "PPID",
  measure.vars = patterns( # cannot access patterns directly! need to load data.table library!!!
    affAnx = "affAnx",
    affCalm = "affCalm",
    affDepr = "affDepr",
    affEnerg = "affEnerg",
    affNerv = "affNerv",
    affInsp = "affInsp",
    affRel = "affRel",
    affExh = "affExh",
    PFS01 = "PFS01",
    happy = "happy",
    lifeSat = "lifeSat",
    fail01 = "fail01", 
    # c19ProSo01 = "c19ProSo01",
    c19ProSo03 = "c19ProSo03"),
  variable.name = "wave"
  )
rm(tmp)

# add non-longitudinal variables to dataset
tmp <- dtFullRed %>%
  select(PPID,
         coded_country)

dtLong <- dtLong %>%
  dplyr::left_join(tmp, by = "PPID"); rm(tmp)
```

#### Scales
```{r, echo=FALSE}

# input = dtLong
# waveNum = 2
# varNames = c("affAnx", "affDepr", "affNerv", "affExh")

# load function for averaging per wave
long_scale_calc <- function(input, waveNum, varNames) {
  
  input <- input %>%
  filter(wave == waveNum) %>%
  select(contains(varNames))

# check whether minimum is the same across input columns
  testMin = list()
  testMin$test <- input %>%
    summarise_each(funs(min(., na.rm = T)))%>%
    table()
  testMin$num <- input %>%
    summarise_each(funs(min(., na.rm = T))) %>%
    as.numeric()
  ifelse(ncol(testMin$test) & nrow(testMin$test) == 1, 
         print("All input variables have the same minimum"), 
         stop("Warning: Minimum seems to differ across input variables"))

# check whether maximum is the same across input columns
  testMax = list()
  testMax$test <- input %>%
    summarise_each(funs(max(., na.rm = T)))%>%
    table()
  testMax$num <- input %>%
    summarise_each(funs(max(., na.rm = T))) %>%
    as.numeric()
  ifelse(ncol(testMax$test) & nrow(testMax$test) == 1, 
         print("All input variables have the same maximum"), 
         stop("Warning: Maximum seems to differ across input variables"))
  
# calculate scale
  scaleCalc <- scoreItems(keys=rep(1, ncol(input)),
                          items = input,
                          min = testMin$num[1], max = testMax$num[1],
                          impute = "none")
  
  print(paste("Alpha for the following items in wave ", waveNum, ":", sep = ""))
  print(varNames)
  print(round(scaleCalc$alpha, 2))
  
  output <- round(as.numeric(scaleCalc$scores), 3)

  return(output)
  rm(testMin, testMax, scaleCalc, output, input)
}
```

##### calculate scales
```{r, echo=FALSE}
# ---------------- positive emotion-----------------
# create df for filling
  tmp <- data.table(matrix(NA, nrow = nrow(dtFullRed), ncol = 23))

# calculate scale per wave
  for (waveNum in 1:max(as.numeric(dtLong$wave))) {
    tmp[,waveNum] <- long_scale_calc(input = dtLong, waveNum = waveNum, varNames = c("affCalm", "affEnerg", "affInsp", "affRel"))
  }
  tmp$PPID <- dtFullRed$PPID

# turn into long format again
  tmp2 <- data.table::melt.data.table(
    data = tmp, 
    id.vars = "PPID",
    variable.name = "wave",
    value.name = "scale"
    )
# add to already existing dataframe of long data
  dtLong$posEmo <- as.numeric(tmp2$scale)
  rm(tmp, tmp2)

# ---------------- negative emotion-----------------
# create df for filling
  tmp <- data.table(matrix(NA, nrow = nrow(dtFullRed), ncol = 23))

# calculate scale per wave
  for (waveNum in 1:max(as.numeric(dtLong$wave))) {
    tmp[,waveNum] <- long_scale_calc(input = dtLong, waveNum = waveNum, varNames = c("affAnx", "affDepr", "affNerv", "affExh"))
  }
  tmp$PPID <- dtFullRed$PPID

# turn into long format again
  tmp2 <- data.table::melt.data.table(
    data = tmp, 
    id.vars = "PPID",
    variable.name = "wave",
    value.name = "scale"
    )
# add to already existing dataframe of long data
  dtLong$negEmo <- as.numeric(tmp2$scale)
  rm(tmp, tmp2)
  
dtLong[dtLong == "NaN"] <- NA
```

##### create centered variables (center within clsuter)
https://kzee.github.io/Centering_Demo.html (blml::isolate unfortunately does not work)
```{r}
# calculate mean and sds per participant
dtLong <- dtLong %>%
  group_by(PPID) %>%
  mutate(
    negEmo_mean = mean(negEmo, na.rm = T),
    negEmo_sd = sd(negEmo, na.rm = T),
    posEmo_mean = mean(posEmo, na.rm = T),
    posEmo_sd = sd(posEmo, na.rm = T),
    PFS01_mean = mean(PFS01, na.rm = T),
    PFS01_sd = sd(PFS01, na.rm = T),
    fail01_mean = mean(fail01, na.rm = T),
    fail01_sd = sd(fail01, na.rm = T),
    happy_mean = mean(happy, na.rm = T),
    happy_sd = sd(happy, na.rm = T),
    c19ProSo03_mean = mean(c19ProSo03, na.rm = T),
    c19ProSo03_sd = sd(c19ProSo03, na.rm = T)
  ) %>%
  ungroup()

# calculate mean and sds per country
dtLong <- dtLong %>%
  group_by(coded_country) %>%
  mutate(
    negEmoCountry_mean = mean(negEmo_mean, na.rm = T),
    negEmoCountry_sd = sd(negEmo_mean, na.rm = T),
    posEmoCountry_mean = mean(posEmo_mean, na.rm = T),
    posEmoCoutry_sd = sd(posEmo_mean, na.rm = T),
    PFS01Country_mean = mean(PFS01_mean, na.rm = T),
    PFS01Country_sd = sd(PFS01_mean, na.rm = T),
    fail01Country_mean = mean(fail01_mean, na.rm = T),
    fail01Country_sd = sd(fail01_mean, na.rm = T),
    happyCountry_mean = mean(happy_mean, na.rm = T),
    happyCountry_sd = sd(happy_mean, na.rm = T),
    c19ProSo03Country_mean = mean(c19ProSo03_mean, na.rm = T),
    c19ProSo03Country_sd = sd(c19ProSo03_mean, na.rm = T),
  ) %>%
  ungroup()


# center within (for grand mean centering or between-person centering see above link)
dtLong <- dtLong %>%
  ungroup() %>%
  mutate(
    negEmoCtry_c = scale(negEmoCountry_mean, center = T, scale = F),
    posEmoCtry_c = scale(posEmoCountry_mean, center = T, scale = F),
    disempCtry_c = scale(fail01Country_mean, center = T, scale = F),
    PFSCtry_c = scale(PFS01Country_mean, center = T, scale = F),
    WBCtry_c = scale(happyCountry_mean, center = T, scale = F),
    negEmoPP_c = scale(negEmo_mean, center = T, scale = F),
    posEmoPP_c = scale(posEmo_mean, center = T, scale = F),
    disempPP_c = scale(fail01_mean, center = T, scale = F),
    PFSPP_c = scale(PFS01_mean, center = T, scale = F),
    WBPP_c = scale(happy_mean, center = T, scale = F),
    negEmo_c = scale(negEmo, center = T, scale = F),
    posEmo_c = scale(posEmo, center = T, scale = F),
    disemp_c = scale(fail01, center = T, scale = F),
    PFS_c = scale(PFS01, center = T, scale = F),
    WB_c = scale(happy, center = T, scale = F),
    negEmo_cw = negEmo-negEmo_mean,
    posEmo_cw = posEmo-posEmo_mean,
    disemp_cw = fail01-fail01_mean,
    PFS_cw = PFS01 - PFS01_mean,
    WB_cw = happy-happy_mean,
    negEmoPP_cw = negEmo_mean-negEmoCountry_mean,
    posEmoPP_cw = posEmo_mean-posEmoCountry_mean,
    disempPP_cw = fail01_mean-fail01Country_mean,
    PFSPP_cw =  PFS01_mean-happyCountry_mean,
    WBPP_cw = happy_mean-mean(happy_mean, na.rm = T),
    negEmoCtry_cw = negEmoCountry_mean-mean(negEmoCountry_mean, na.rm = T),
    posEmoCtry_cw = posEmoCountry_mean-mean(posEmoCountry_mean, na.rm = T),
    disempCtry_cw = fail01Country_mean-mean(fail01Country_mean, na.rm = T),
    PFSCtry_cw =  PFS01Country_mean-mean(PFS01Country_mean, na.rm = T),
    WBCtry_cw = happyCountry_mean-mean(happyCountry_mean, na.rm = T),
    WB = happy,
    c19ProSo_cw = c19ProSo03-c19ProSo03_mean
  )
```

# Analysis Cross-Sectional
## Multilevel (Group mean centering)
CMC quite useful when within-cluster and between-cluster slopes may differ and one is mainly interesting in the within-cluster slope (based on Raudenbush and Bryk). As we see (similar to  Hamaker & Grasman, 2014) grand-mean centering (see above) results in larger effects as within-cluster centering biases effects to be smaller (more conservative and still valid)

### Well-Being
http://www.alexanderdemos.org/Mixed5.html#plot_final_results_(fixed_effects_only)

First question: Do we need multilevel modeling? Run intercept only model! If amount of variance on level 2/3 is significant multilevel modeling is handy (but taking into account nestedness almost always is).
```{r}
lm_lv0 <- lm(WB ~ 1, # each person can have its own intercept relative to the country
                  data = dtCross)
ana_lv0 <- lme4::lmer(WB ~ 1 + 
                    (1|coded_country), # each country can have its own intercept relative to the country
                  data = dtCross)

anova(ana_lv0, lm_lv0)
summary(ana_lv0)
performance::icc(ana_lv0)
```

#### level 1 predictors
Second step: Add all level 1 predictors
```{r}
ana_lv1 <- lme4::lmer(WB ~ negEmo_cw + posEmo_cw + PFS_cw + 
                    (1|coded_country), # each country can have its own intercept relative to the country
                  data = dtCross)

summary(ana_lv1)
performance::icc(ana_lv1)

# variances
var_ana_lv1 <- as.data.frame(lme4::VarCorr(ana_lv1))
var_ana_lv0 <- as.data.frame(lme4::VarCorr(ana_lv0))
var_ana_lv0
var_ana_lv1

# plot residuals
saveRes <- residuals(ana_lv1)
plot(saveRes)
```

#### level 2 predictors
If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016)
```{r}
ana_lv12 <- lme4::lmer(WB ~ negEmo_cw + posEmo_cw + PFS_cw +  
                         negEmoCtry_cw + posEmoCtry_cw + PFSCtry_cw + 
                    (1|coded_country), # each country can have its own intercept relative to the country
                  data = dtCross)

summary(ana_lv12)
performance::icc(ana_lv12)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# plot residuals
saveRes <- residuals(ana_lv12)
plot(saveRes)
```

#### save for indirect effects (A path)
http://www.quantpsy.org/medmc/medmc.htm
Selig, J. P., & Preacher, K. J. (2008, June). Monte Carlo method for assessing mediation: An interactive tool for creating confidence intervals for indirect effects [Computer software]. Available from http://quantpsy.org/.
-Run a regression analysis (or path analysis, SEM, etc.) with the IV predicting the mediator. This will give a.
-Run a regression analysis with the IV and mediator predicting the DV. This will give b.
-If you use SEM, path analysis, multilevel modeling, or some other multivariate method to obtain both a and b from a single model, then var(a), var(b), and cov(a,b) can be found in the asymptotic covariance matrix of the parameter estimates. If you use regression to obtain a and b in separate steps, then var(a) and var(b) are simply the squared standard errors, and cov(a,b) = 0.

```{r}
tmp <- summary(ana_lv12)

paths_WB <- data.frame(
  posEmo_A = tmp$coefficients['posEmo_cw','Estimate'],
  posEmo_varA = tmp$coefficients['posEmo_cw','Std. Error'],
  negEmo_A = tmp$coefficients['negEmo_cw','Estimate'],
  negEmo_varA = tmp$coefficients['negEmo_cw','Std. Error'],
  PFS_A = tmp$coefficients['PFS_cw','Estimate'],
  PFS_varA = tmp$coefficients['PFS_cw','Std. Error'],
  posEmoCtry_A = tmp$coefficients['posEmoCtry_cw','Estimate'],
  posEmoCtry_varA = tmp$coefficients['posEmoCtry_cw','Std. Error'],
  negEmoCtry_A = tmp$coefficients['negEmoCtry_cw','Estimate'],
  negEmoCtry_varA = tmp$coefficients['negEmoCtry_cw','Std. Error'],
  PFSCtry_A = tmp$coefficients['PFSCtry_cw','Estimate'],
  PFSCtry_varA = tmp$coefficients['PFSCtry_cw','Std. Error']
)

rm(list=ls(pattern="^tmp"))
```


#### save tables
```{r}
 stargazer::stargazer(ana_lv0, ana_lv1, ana_lv12,
                summary=FALSE,
                type='html',
                rownames = TRUE,
                initial.zero=FALSE,
                ci = TRUE,
                digits=3,
                digits.extra = 3,
                title='WellBeing Group Mean Centering Analyses',
                column.labels = c("randomInt", "level1", "level1-2", "level1-3"),
                dep.var.labels = c("Well-Being"),
                out="output/tables/Cross/WB_CW.html")

WB_cw_out <- mlm_summary_out(ana_lv12)

stargazer::stargazer(WB_cw_out, 
                     out="output/tables/Cross/WB_CW_relOnly.html",
                     summary=FALSE,
                     type='html',
                     digits=3,
                     digits.extra = 3,
                     title='WellBeing Group Mean Centering Analyses')

rm(list=ls(pattern="^ana"))
```

### Pro-Sociality (no well-being)
http://www.alexanderdemos.org/Mixed5.html#plot_final_results_(fixed_effects_only)

We have `r nrow(dtCross)-sum(is.na(dtCross$affAnx))` total measurements.
First question: Do we need multilevel modeling? Run intercept only model! If amount of variance on level 2/3 is significant multilevel modeling is handy (but taking into account nestedness almost always is).
```{r}
lm_0 <- lm(c19ProSo ~ 1, # each country can have its own intercept relative to the country
                  data = dtCross)
ana_lv0 <- lme4::lmer(c19ProSo ~ 1 + 
                    (1|coded_country), # each country can have its own intercept relative to the country
                  data = dtCross)

anova(ana_lv0, lm_0)
summary(ana_lv0)
performance::icc(ana_lv0)

# plot residuals
saveRes <- residuals(ana_lv0)
plot(saveRes)
```

#### level 1 predictors
Second step: Add all level 1 predictors
```{r}
ana_lv1 <- lme4::lmer(c19ProSo ~ negEmo_cw + posEmo_cw + PFS_cw +  
                    (1|coded_country), # each country can have its own intercept relative to the country
                  data = dtCross)

summary(ana_lv1)
performance::icc(ana_lv1)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana_lv1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana_lv0))
# var.ana.0
# var.ana.1

# plot residuals
saveRes <- residuals(ana_lv1)
plot(saveRes)
```

#### level 2 predictors
If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016)
```{r}
ana_lv12 <- lme4::lmer(c19ProSo ~ negEmo_cw + posEmo_cw + PFS_cw +   
                         negEmoCtry_cw + posEmoCtry_cw + PFSCtry_cw +  
                    (1|coded_country), # each country can have its own intercept relative to the country
                  data = dtCross)

summary(ana_lv12)
performance::icc(ana_lv12)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# plot residuals
saveRes <- residuals(ana_lv12)
plot(saveRes)
```

#### save tables
```{r}
 stargazer::stargazer(ana_lv0, ana_lv1, ana_lv12,
                summary=FALSE,
                type='html',
                rownames = TRUE,
                initial.zero=FALSE,
                ci = TRUE,
                digits=2,
                digits.extra = 2,
                #order = c(1, 17, 21, 2, 18, 22, 3, 19, 23, 16, 20, 24, 4, 7, 10, 13, 5, 8, 11, 14, 6, 9, 12, 15),
                title='ProSocial Group Mean Centering Analyses',
                column.labels = c("randomInt", "level1", "level1-2", "level1-3"),
                dep.var.labels = c("ProSocial"),
                out="output/tables/Cross/proSo_noWellBeing_CW.html")

proSo_noWellBeing_CW_out <- mlm_summary_out(ana_lv12)

stargazer::stargazer(proSo_noWellBeing_CW_out, 
                     out="output/tables/Cross/proSo_noWellBeing_CW_relOnly.html",
                     summary=FALSE,
                     type='html',
                     digits=3,
                     digits.extra = 3,
                     title='ProSocial Group Mean Centering Analyses (no wellbeing)')

rm(list=ls(pattern="^ana"))
```

### Pro-Sociality (controlling for Well-Being)
http://www.alexanderdemos.org/Mixed5.html#plot_final_results_(fixed_effects_only)

We have `r nrow(dtCross)-sum(is.na(dtCross$affAnx))` total measurements.
First question: Do we need multilevel modeling? Run intercept only model! If amount of variance on level 2/3 is significant multilevel modeling is handy (but taking into account nestedness almost always is).
```{r}
lm_0 <- lm(c19ProSo ~ 1, # each country can have its own intercept relative to the country
                  data = dtCross)
ana_lv0 <- lme4::lmer(c19ProSo ~ 1 + 
                    (1|coded_country), # each country can have its own intercept relative to the country
                  data = dtCross)

anova(ana_lv0, lm_0)
summary(ana_lv0)
performance::icc(ana_lv0)

# plot residuals
saveRes <- residuals(ana_lv0)
plot(saveRes)
```

#### level 1 predictors
Second step: Add all level 1 predictors
```{r}
ana_lv1 <- lme4::lmer(c19ProSo ~ negEmo_cw + posEmo_cw + PFS_cw + WB_cw +
                    (1|coded_country), # each country can have its own intercept relative to the country
                  data = dtCross)

summary(ana_lv1)
performance::icc(ana_lv1)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana_lv1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana_lv0))
# var.ana.0
# var.ana.1

# plot residuals
saveRes <- residuals(ana_lv1)
plot(saveRes)
```

#### level 2 predictors
If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016)
```{r}
ana_lv12 <- lme4::lmer(c19ProSo ~ negEmo_cw + posEmo_cw + PFS_cw + WB_cw + 
                         negEmoCtry_cw + posEmoCtry_cw + PFSCtry_cw + WBCtry_cw +
                    (1|coded_country), # each country can have its own intercept relative to the country
                  data = dtCross)

summary(ana_lv12)
performance::icc(ana_lv12)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# plot residuals
saveRes <- residuals(ana_lv12)
plot(saveRes)
```

#### save for indirect effects (B path)
```{r}
tmp <- summary(ana_lv12)

paths_proSo <- data.frame(
  WB_B = tmp$coefficients['WB_cw','Estimate'],
  WB_varB = tmp$coefficients['WB_cw','Std. Error'],
  WBCtry_B = tmp$coefficients['WBCtry_cw','Estimate'],
  WBCtry_varB = tmp$coefficients['WBCtry_cw','Std. Error']
)
rm(tmp)
```

#### save tables
```{r}
 stargazer::stargazer(ana_lv0, ana_lv1, ana_lv12,
                summary=FALSE,
                type='html',
                rownames = TRUE,
                initial.zero=FALSE,
                ci = TRUE,
                digits=2,
                digits.extra = 2,
                # order = c(1, 22, 27, 2, 23, 28, 3, 24, 29, 4, 25, 30, 5, 26, 31, 6, 10, 14, 18, 7, 11, 15, 19, 8, 12, 16, 20, 9, 13, 17, 21),
                title='ProSocial Group Mean Centering Analyses',
                column.labels = c("randomInt", "level1", "level1-2", "level1-3"),
                dep.var.labels = c("ProSocial"),
                out="output/tables/Cross/proSo_CW.html")

proSo_CW_out <- mlm_summary_out(ana_lv12)

stargazer::stargazer(proSo_CW_out, 
                     out="output/tables/Cross/proSo_CW_relOnly.html",
                     summary=FALSE,
                     type='html',
                     digits=3,
                     digits.extra = 3,
                     title='ProSocial Group Mean Centering Analyses')

#rm(list=ls(pattern="^ana"))
```

### calculate indirect effects
```{r}
dt_indirect <- data.frame(
# positive emotion
  # within participant level
  calc_indirect_effect(
    nameIn = "posEmo",
    pathA = paths_WB$posEmo_A,
    varA = paths_WB$posEmo_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
   conf = 0.99),
  # country level
  calc_indirect_effect(
    nameIn = "posEmoPP",
    pathA = paths_WB$posEmoCtry_A,
    varA = paths_WB$posEmoCtry_varA,
    pathB = paths_proSo$WBCtry_B,
    varB = paths_proSo$WBCtry_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  
# negative emotion
  # within participant level
  calc_indirect_effect(
    nameIn = "negEmo",
    pathA = paths_WB$negEmo_A,
    varA = paths_WB$negEmo_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
   conf = 0.99),
  # country level
  calc_indirect_effect(
    nameIn = "negEmoPP",
    pathA = paths_WB$negEmoCtry_A,
    varA = paths_WB$negEmoCtry_varA,
    pathB = paths_proSo$WBCtry_B,
    varB = paths_proSo$WBCtry_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  
# perceived financial strain
  # within participant level
  calc_indirect_effect(
    nameIn = "PFS",
    pathA = paths_WB$PFS_A,
    varA = paths_WB$PFS_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
   conf = 0.99),
  # between participant level
  calc_indirect_effect(
    nameIn = "PFSPP",
    pathA = paths_WB$PFSCtry_A,
    varA = paths_WB$PFSCtry_varA,
    pathB = paths_proSo$WBCtry_B,
    varB = paths_proSo$WBCtry_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99)
)

dt_indirect <- matrix(unlist(t(dt_indirect)), byrow = T, nrow = ncol(dt_indirect)/3, ncol = 3)

stargazer::stargazer(dt_indirect, 
                     out="output/tables/Cross/indirect_effects.html",
                     summary=FALSE,
                     type='html',
                     digits=3,
                     digits.extra = 3,
                     title='Indirect effects')



```


# Analysis Longitudinal
Only looking at contemporaneous effects (nothing lagged/causal)
Not causal/lagged because measurement points to different and too long apart from each other (see autocorrelation)

## Multilevel (Group mean centering)
CMC quite useful when within-cluster and between-cluster slopes may differ and one is mainly interesting in the within-cluster slope (based on Raudenbush and Bryk). As we see (similar to  Hamaker & Grasman, 2014) grand-mean centering (see above) results in larger effects as within-cluster centering biases effects to be smaller (more conservative and still valid)

### Well-Being
http://www.alexanderdemos.org/Mixed5.html#plot_final_results_(fixed_effects_only)

First question: Do we need multilevel modeling? Run intercept only model! If amount of variance on level 2/3 is significant multilevel modeling is handy (but taking into account nestedness almost always is).
```{r}
lm_lv0 <- lm(WB ~ 1, # each person can have its own intercept relative to the country
                  data = dtLong)
ana_lv0 <- lme4::lmer(WB ~ 1 + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

anova(ana_lv0, lm_lv0)
summary(ana_lv0)
performance::icc(ana_lv0)

# calculate the ACF for lags between 1 and 50 (inclusive); probably not too important due to the large amount of missingness
tmp <- dtLong %>% # sort after participant (if we have autocorrelation every 25 measurement should repeat)
  arrange(PPID)

autocorrelation <- acf(dtLong$WB, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(tmp, autocorrelation)

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv0)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### level 1 predictors
Second step: Add all level 1 predictors
```{r}
ana_lv1 <- lme4::lmer(WB ~ negEmo_cw + posEmo_cw + PFS_cw + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv1)
performance::icc(ana_lv1)

# variances
var_ana_lv1 <- as.data.frame(lme4::VarCorr(ana_lv1))
var_ana_lv0 <- as.data.frame(lme4::VarCorr(ana_lv0))
var_ana_lv0
var_ana_lv1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv1)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation, var_ana_lv0, var_ana_lv1)
```

#### level 2 predictors
If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016)
```{r}
ana_lv12 <- lme4::lmer(WB ~ negEmo_cw + posEmo_cw + PFS_cw +  
                         negEmoPP_cw + posEmoPP_cw + PFSPP_cw + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv12)
performance::icc(ana_lv12)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv12)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### level 3 predictors
If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016)
```{r}
ana_lv123 <- lme4::lmer(WB ~ negEmo_cw + posEmo_cw + PFS_cw +  
                          negEmoPP_cw + posEmoPP_cw + PFSPP_cw +  
                      negEmoCtry_cw + posEmoCtry_cw + PFSCtry_cw + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv123)
performance::icc(ana_lv123)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv123)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### save for indirect effects (A path)
http://www.quantpsy.org/medmc/medmc.htm
Selig, J. P., & Preacher, K. J. (2008, June). Monte Carlo method for assessing mediation: An interactive tool for creating confidence intervals for indirect effects [Computer software]. Available from http://quantpsy.org/.
-Run a regression analysis (or path analysis, SEM, etc.) with the IV predicting the mediator. This will give a.
-Run a regression analysis with the IV and mediator predicting the DV. This will give b.
-If you use SEM, path analysis, multilevel modeling, or some other multivariate method to obtain both a and b from a single model, then var(a), var(b), and cov(a,b) can be found in the asymptotic covariance matrix of the parameter estimates. If you use regression to obtain a and b in separate steps, then var(a) and var(b) are simply the squared standard errors, and cov(a,b) = 0.

```{r}
tmp <- summary(ana_lv123)

paths_WB <- data.frame(
  posEmo_A = tmp$coefficients['posEmo_cw','Estimate'],
  posEmo_varA = tmp$coefficients['posEmo_cw','Std. Error'],
  negEmo_A = tmp$coefficients['negEmo_cw','Estimate'],
  negEmo_varA = tmp$coefficients['negEmo_cw','Std. Error'],
  PFS_A = tmp$coefficients['PFS_cw','Estimate'],
  PFS_varA = tmp$coefficients['PFS_cw','Std. Error'],
  posEmoPP_A = tmp$coefficients['posEmoPP_cw','Estimate'],
  posEmoPP_varA = tmp$coefficients['posEmoPP_cw','Std. Error'],
  negEmoPP_A = tmp$coefficients['negEmoPP_cw','Estimate'],
  negEmoPP_varA = tmp$coefficients['negEmoPP_cw','Std. Error'],
  PFSPP_A = tmp$coefficients['PFSPP_cw','Estimate'],
  PFSPP_varA = tmp$coefficients['PFSPP_cw','Std. Error'],
  posEmoCtry_A = tmp$coefficients['posEmoCtry_cw','Estimate'],
  posEmoCtry_varA = tmp$coefficients['posEmoCtry_cw','Std. Error'],
  negEmoCtry_A = tmp$coefficients['negEmoCtry_cw','Estimate'],
  negEmoCtry_varA = tmp$coefficients['negEmoCtry_cw','Std. Error'],
  PFSCtry_A = tmp$coefficients['PFSCtry_cw','Estimate'],
  PFSCtry_varA = tmp$coefficients['PFSCtry_cw','Std. Error']
)

rm(list=ls(pattern="^tmp"))
```


#### save tables
```{r}
 stargazer::stargazer(ana_lv0, ana_lv1, ana_lv12, ana_lv123,
                summary=FALSE,
                type='html',
                rownames = TRUE,
                initial.zero=FALSE,
                ci = TRUE,
                digits=3,
                digits.extra = 3,
                # order = c(1, 17, 21, 2, 18, 22, 3, 19, 23, 16, 20, 24, 4, 7, 10, 13, 5, 8, 11, 14, 6, 9, 12, 15),
                title='WellBeing Group Mean Centering Analyses',
                column.labels = c("randomInt", "level1", "level1-2", "level1-3"),
                dep.var.labels = c("Well-Being"),
                out="output/tables/Longitudinal/WB_CW.html")

# stargazer::stargazer(ana_lv123_intCrossAll,
#                 summary=FALSE,
#                 type='html',
#                 rownames = TRUE,
#                 initial.zero=TRUE,
#                 ci = TRUE,
#                 digits=3,
#                 digits.extra = 3,
#                 p.auto = T,
#                 title='WellBeing Analyses',
#                 # column.labels = c(),
#                 dep.var.labels = c("Well-Being"),
#                 out="output/tables/Longitudinal/oldWB_CW.html")

WB_cw_out <- mlm_summary_out(ana_lv123)

stargazer::stargazer(WB_cw_out, 
                     out="output/tables/Longitudinal/WB_CW_relOnly.html",
                     summary=FALSE,
                     type='html',
                     digits=3,
                     digits.extra = 3,
                     title='WellBeing Group Mean Centering Analyses')

rm(list=ls(pattern="^ana"))
```

### Pro-Sociality (no well-being)
http://www.alexanderdemos.org/Mixed5.html#plot_final_results_(fixed_effects_only)

We have `r nrow(dtLong)-sum(is.na(dtLong$affAnx))` total measurements.
First question: Do we need multilevel modeling? Run intercept only model! If amount of variance on level 2/3 is significant multilevel modeling is handy (but taking into account nestedness almost always is).
```{r}
lm_0 <- lm(c19ProSo03 ~ 1, # each person can have its own intercept relative to the country
                  data = dtLong)
ana_lv0 <- lme4::lmer(c19ProSo03 ~ 1 + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

anova(ana_lv0, lm_0)
summary(ana_lv0)
performance::icc(ana_lv0)

# calculate the ACF for lags between 1 and 50 (inclusive); probably not too important due to the large amount of missingness
tmp <- dtLong %>% # sort after participant (if we have autocorrelation every 25 measurement should repeat)
  arrange(PPID)

autocorrelation <- acf(dtLong$c19ProSo03, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(tmp, autocorrelation)

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv0)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### level 1 predictors
Second step: Add all level 1 predictors
```{r}
ana_lv1 <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw +  
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv1)
performance::icc(ana_lv1)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana_lv1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana_lv0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv1)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### level 2 predictors
If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016)
```{r}
ana_lv12 <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw +   
                         negEmoPP_cw + posEmoPP_cw + PFSPP_cw +  
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv12)
performance::icc(ana_lv12)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv12)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### level 3 predictors
If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016)
```{r}
ana_lv123 <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw +   
                      negEmoPP_cw + posEmoPP_cw + PFSPP_cw +  
                      negEmoCtry_cw + posEmoCtry_cw + PFSCtry_cw +  
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv123)
performance::icc(ana_lv123)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv123)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### save tables
```{r}
 stargazer::stargazer(ana_lv0, ana_lv1, ana_lv12, ana_lv123, 
                summary=FALSE,
                type='html',
                rownames = TRUE,
                initial.zero=FALSE,
                ci = TRUE,
                digits=2,
                digits.extra = 2,
                #order = c(1, 17, 21, 2, 18, 22, 3, 19, 23, 16, 20, 24, 4, 7, 10, 13, 5, 8, 11, 14, 6, 9, 12, 15),
                title='ProSocial Group Mean Centering Analyses',
                column.labels = c("randomInt", "level1", "level1-2", "level1-3"),
                dep.var.labels = c("ProSocial"),
                out="output/tables/Longitudinal/proSo_noWellBeing_CW.html")

# stargazer::stargazer(ana_lv0, ana_lv1, ana_lv1_int, ana_lv12, ana_lv12_int, ana_lv123, ana_lv123_int, 
#                       ana_lv123_intCrossAll, ana_lv123_intCrossOnly,
#                 summary=FALSE,
#                 type='html',
#                 rownames = TRUE,
#                 initial.zero=FALSE,
#                 ci = TRUE,
#                 digits=2,
#                 digits.extra = 2,
#                 # order = c(1, 14, 18, 2, 15, 19, 3, 16, 20),
#                 title='ProSocial Group Mean Centering Analyses',
#                 column.labels = c("randomInt", "level1", "level1+int", "level1-2", "level1-2+int", "level1-3", "level1-3+int"),
#                 dep.var.labels = c("ProSocial"),
#                 out="output/tables/Longitudinal/proSo_noWellBeing_CW.html")
# 
proSo_noWellBeing_CW_out <- mlm_summary_out(ana_lv123)

stargazer::stargazer(proSo_noWellBeing_CW_out, 
                     out="output/tables/Longitudinal/proSo_noWellBeing_CW_relOnly.html",
                     summary=FALSE,
                     type='html',
                     digits=3,
                     digits.extra = 3,
                     title='ProSocial Group Mean Centering Analyses (no wellbeing)')

rm(list=ls(pattern="^ana"))
```

### Pro-Sociality (controlling for Well-Being)
http://www.alexanderdemos.org/Mixed5.html#plot_final_results_(fixed_effects_only)

We have `r nrow(dtLong)-sum(is.na(dtLong$affAnx))` total measurements.
First question: Do we need multilevel modeling? Run intercept only model! If amount of variance on level 2/3 is significant multilevel modeling is handy (but taking into account nestedness almost always is).
```{r}
lm_0 <- lm(c19ProSo03 ~ 1, # each person can have its own intercept relative to the country
                  data = dtLong)
ana_lv0 <- lme4::lmer(c19ProSo03 ~ 1 + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

anova(ana_lv0, lm_0)
summary(ana_lv0)
performance::icc(ana_lv0)

# calculate the ACF for lags between 1 and 50 (inclusive); probably not too important due to the large amount of missingness
tmp <- dtLong %>% # sort after participant (if we have autocorrelation every 25 measurement should repeat)
  arrange(PPID)

autocorrelation <- acf(dtLong$c19ProSo03, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(tmp, autocorrelation)

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv0)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### level 1 predictors
Second step: Add all level 1 predictors
```{r}
ana_lv1 <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw + WB_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv1)
performance::icc(ana_lv1)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana_lv1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana_lv0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv1)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### level 2 predictors
If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016)
```{r}
ana_lv12 <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw + WB_cw + 
                         negEmoPP_cw + posEmoPP_cw + PFSPP_cw + WBPP_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv12)
performance::icc(ana_lv12)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv12)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### level 3 predictors
If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016)
```{r}
ana_lv123 <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw + WB_cw + 
                      negEmoPP_cw + posEmoPP_cw + PFSPP_cw + WBPP_cw +
                      negEmoCtry_cw + posEmoCtry_cw + PFSCtry_cw + WBCtry_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv123)
performance::icc(ana_lv123)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv123)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### save for indirect effects (B path)
```{r}
tmp <- summary(ana_lv123)

paths_proSo <- data.frame(
  WB_B = tmp$coefficients['WB_cw','Estimate'],
  WB_varB = tmp$coefficients['WB_cw','Std. Error'],
  WBPP_B = tmp$coefficients['WBPP_cw','Estimate'],
  WBPP_varB = tmp$coefficients['WBPP_cw','Std. Error'],
  WBCtry_B = tmp$coefficients['WBCtry_cw','Estimate'],
  WBCtry_varB = tmp$coefficients['WBCtry_cw','Std. Error']
)
rm(tmp)
```

#### save tables
```{r}
 stargazer::stargazer(ana_lv0, ana_lv1, ana_lv12, ana_lv123, 
                summary=FALSE,
                type='html',
                rownames = TRUE,
                initial.zero=FALSE,
                ci = TRUE,
                digits=2,
                digits.extra = 2,
                # order = c(1, 22, 27, 2, 23, 28, 3, 24, 29, 4, 25, 30, 5, 26, 31, 6, 10, 14, 18, 7, 11, 15, 19, 8, 12, 16, 20, 9, 13, 17, 21),
                title='ProSocial Group Mean Centering Analyses',
                column.labels = c("randomInt", "level1", "level1-2", "level1-3"),
                dep.var.labels = c("ProSocial"),
                out="output/tables/Longitudinal/proSo_CW.html")

# stargazer::stargazer(ana_lv0, ana_lv1, ana_lv12, ana_lv123, 
#                 summary=FALSE,
#                 type='html',
#                 rownames = TRUE,
#                 initial.zero=FALSE,
#                 ci = TRUE,
#                 digits=2,
#                 digits.extra = 2,
#                 # order = c(1, 14, 18, 2, 15, 19, 3, 16, 20),
#                 title='ProSocial Group Mean Centering Analyses',
#                 column.labels = c("randomInt", "level1", "level1-2", "level1-3"),
#                 dep.var.labels = c("ProSocial"),
#                 out="output/tables/Longitudinal/oldproSo_CW.html")

proSo_CW_out <- mlm_summary_out(ana_lv123)

stargazer::stargazer(proSo_CW_out, 
                     out="output/tables/Longitudinal/proSo_CW_relOnly.html",
                     summary=FALSE,
                     type='html',
                     digits=3,
                     digits.extra = 3,
                     title='ProSocial Group Mean Centering Analyses')

#rm(list=ls(pattern="^ana"))
```

### calculate indirect effects
```{r}
dt_indirect <- data.frame(
# positive emotion
  # within participant level
  calc_indirect_effect(
    nameIn = "posEmo",
    pathA = paths_WB$posEmo_A,
    varA = paths_WB$posEmo_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
   conf = 0.99),
  # between participant level
  calc_indirect_effect(
    nameIn = "posEmoPP",
    pathA = paths_WB$posEmoPP_A,
    varA = paths_WB$posEmoPP_varA,
    pathB = paths_proSo$WBPP_B,
    varB = paths_proSo$WBPP_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  # country level
  calc_indirect_effect(
    nameIn = "posEmoCtry",
    pathA = paths_WB$posEmoCtry_A,
    varA = paths_WB$posEmoCtry_varA,
    pathB = paths_proSo$WBCtry_B,
    varB = paths_proSo$WBCtry_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  
# negative emotion
  # within participant level
  calc_indirect_effect(
    nameIn = "negEmo",
    pathA = paths_WB$negEmo_A,
    varA = paths_WB$negEmo_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
   conf = 0.99),
  # between participant level
  calc_indirect_effect(
    nameIn = "negEmoPP",
    pathA = paths_WB$negEmoPP_A,
    varA = paths_WB$negEmoPP_varA,
    pathB = paths_proSo$WBPP_B,
    varB = paths_proSo$WBPP_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  # Country level
  calc_indirect_effect(
    nameIn = "negEmoCtry",
    pathA = paths_WB$negEmoCtry_A,
    varA = paths_WB$negEmoCtry_varA,
    pathB = paths_proSo$WBCtry_B,
    varB = paths_proSo$WBCtry_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
 
  # perceived financial strain
  # within participant level
  calc_indirect_effect(
    nameIn = "PFS",
    pathA = paths_WB$PFS_A,
    varA = paths_WB$PFS_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
   conf = 0.99),
  # between participant level
  calc_indirect_effect(
    nameIn = "PFSPP",
    pathA = paths_WB$PFSPP_A,
    varA = paths_WB$PFSPP_varA,
    pathB = paths_proSo$WBPP_B,
    varB = paths_proSo$WBPP_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  # country level
  calc_indirect_effect(
    nameIn = "PFSCtry",
    pathA = paths_WB$PFSCtry_A,
    varA = paths_WB$PFSCtry_varA,
    pathB = paths_proSo$WBCtry_B,
    varB = paths_proSo$WBCtry_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99)
)

dt_indirect <- matrix(unlist(t(dt_indirect)), byrow = T, nrow = ncol(dt_indirect)/3, ncol = 3)

stargazer::stargazer(dt_indirect, 
                     out="output/tables/Longitudinal/indirect_effects.html",
                     summary=FALSE,
                     type='html',
                     digits=3,
                     digits.extra = 3,
                     title='Indirect effects')



```

```{r}
# run all
```

