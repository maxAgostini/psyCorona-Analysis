---
title: "PsyCorona"
author: "Maximilian Agostini"
date: "May 2020"
output:
  html_document:
    code_folding: hide
    mathjax: default
    theme: united
    toc: yes
    toc_float: yes
    number_sections: TRUE
  pdf_document:
    toc: yes
---

<style type="text/css">
.main-container {
  max-width: 1200px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r setup, include=FALSE}
cat("\014") # clear console
rm(list=ls()) # clear workspace
gc # garbage collector

require(pacman)
p_load(metafor, tidyr, dplyr, tinytex, knitr, kableExtra, DescTools, reshape2, metaSEM, lavaan, semPlot, psych, ggplot2, MplusAutomation, bmlm)

set.seed(52) # set overall random seed for reproducibility

# function to calculate indirect effects
calc_indirect_effect <- function(nameIn, pathA, pathB, varA, varB, covAB, rep, conf) {
   pest=c(pathA,pathB)
   acov <- matrix(c(varA, covAB,covAB, varB),2,2)
   mcmc <- MASS::mvrnorm(rep,pest,acov,empirical=FALSE)
  ab <- mcmc[,1]*mcmc[,2]
  low=(1-conf/100)/2
  upp=((1-conf/100)/2)+(conf/100)
  LL=quantile(ab,low)
  UL=quantile(ab,upp)
  LL4=format(LL,digits=4)
  UL4=format(UL,digits=4)
  hist(ab,breaks='FD',col='skyblue',xlab=paste(conf,'% Confidence Interval ','LL',LL4,'  UL',UL4),
  main='Distribution of Indirect Effect')
  
  # get lower and upper bound
  out <- data.frame(nameIn = as.character(nameIn), LL = round(LL, 3), UL = round(UL, 3))
  return(out)
}

# function to get summary statistics for MLM
mlm_summary_out <- function(model) {
   
  CI = lme4::confint.merMod(model, method = "boot", nsim = 30) # increase to 500 for serious run! 
 
   dt <- data.frame(B = lme4::fixef(model),
      SE = summary(model)$coefficients[,2],
      p = parameters::p_value(model)$p,
      CI_low_boots = CI[4:nrow(CI),1],
      CI_high_boots = CI[4:nrow(CI),2],
      CI_low = lme4::fixef(model)-1.96*summary(model)$coefficients[,2],
      CI_up = lme4::fixef(model)+1.96*summary(model)$coefficients[,2])%>%
  round(., 3)
   return(dt)
}
```

# Load Data
```{r LoadRawBase, echo=T, warning=F, message=F}
# Import Data
dtRaw <- haven::read_spss(dir("data", pattern = "Agostini", full.names = TRUE, ignore.case = TRUE))
```

# Prepare Data
## Cleaning
```{r clean, echo=T, warning=F, message=F}
# change all -99 into NA
  dtRaw[dtRaw == -99] <- NA

# add running number as pp
  dtRaw$PPID <- c(1:nrow(dtRaw))

# make relevant dfs
dtFull <- dtRaw

# make relevant vars numeric
dtFull <- dtFull %>%
  dplyr::mutate_at(vars(matches(
    paste(c("aff", "PFS", "fail", "happy", "lifeSat", "MLQ", "c19ProSo"), collapse = "|"), -contains("DO"))), #vars changed
    as.numeric) #function for change

# create between subjects baseline df
dtCtry <- dtRaw %>% 
  group_by(coded_country) %>% # group by country
  filter(n() > 20) # remove countries with less than 100 people
dtCtry <- dtCtry %>% #needs to be ungrouped for the scale calculation
  ungroup()
table(dtCtry$coded_country)
rm(dtRaw)
```

### Calc relevant stats
```{r}
# calculate number of measurement points (based on hope variable as most people answered it)
tmp <- dtFull %>%
  select(contains("c19Hope"),
         -contains("DO"))%>%
  mutate_all(., as.numeric)

# replace non-missing values with 1 and missing values with 0
tmp[!is.na(tmp)] <- 1
tmp[is.na(tmp)] <- 0

# rowSum to get number of entries per participant
dtFull$numMsr <- rowSums(tmp)
table(dtFull$numMsr); rm(tmp)

```

## Continue cleaning
```{r}
# remove participants for long data with less than two measurements
dtFullRed <- dtFull %>%
  filter(numMsr > 2) # could be handy but not really solves a problem (data over time argument)

# remove countries with less than 20 people
table(dtFullRed$coded_country)

dtFullRed <- dtFullRed %>% 
  group_by(coded_country) %>% # group by country
  filter(n() > 20) # remove countries with less than 100 people
dtFullRed <- dtFullRed %>% #needs to be ungrouped for the scale calculation
  ungroup()
table(dtFullRed$coded_country)

```

## Calculate relevant variables
<!-- ### Baseline -->
<!-- #### Scales -->
<!-- ```{r calcVars, echo=T, warning=F, message=F} -->
<!-- # positive emotion -->
<!--   dtCtry %>% dplyr::select(affCalm, affContent, affEnerg, affInsp, affRel) %>% psych::describe() -->
<!--   dtCtry$posEmo.m <- as.numeric(scoreItems(keys=c(1,1,1,1,1), # as.numeric is needed for Mplus later (does only take one-dimensional objects) -->
<!--                             items = dtCtry %>% dplyr::select(affCalm, affContent, affEnerg, affInsp, affRel) %>% na_if(., -99), -->
<!--                                 min = 1, max = 5)$scores) -->
<!--   dtCtry$posEmo.c <- as.numeric(scale(dtCtry$posEmo.m, scale = F, center = T)) -->
<!--   dtCtry$posEmo.z <- as.numeric(scale(dtCtry$posEmo.m, scale = T)) -->
<!--   dtCtry$posEmo.fa <- as.numeric(fa(dtCtry %>% dplyr::select(affCalm, affContent, affEnerg, affInsp, affRel))$scores) -->

<!-- # negative emotion -->
<!--   dtCtry %>% dplyr::select(affAnx, affDepr, affNerv, affExh) %>% psych::describe() -->
<!--   dtCtry$negEmo.m <- as.numeric(scoreItems(keys=c(1,1,1,1), -->
<!--                             items = dtCtry %>% dplyr::select(affAnx, affDepr, affNerv, affExh) %>% na_if(., -99), -->
<!--                                 min = 1, max = 5)$scores) -->
<!--   dtCtry$negEmo.c <- as.numeric(scale(dtCtry$negEmo.m, scale = F, center = T)) -->
<!--   dtCtry$negEmo.z <- as.numeric(scale(dtCtry$negEmo.m, scale = T)) -->
<!--   dtCtry$negEmo.fa <- as.numeric(fa(dtCtry %>% dplyr::select(affAnx, affDepr, affNerv, affExh))$scores) -->

<!-- # financial strain -->
<!--   dtCtry %>% dplyr::select(PFS01, PFS02, PFS03) %>% psych::describe() -->
<!--   dtCtry$PFS.m <- as.numeric(scoreItems(keys=c(1,1,1), -->
<!--                             items = dtCtry %>% dplyr::select(PFS01, PFS02, PFS03) %>% na_if(., -99), -->
<!--                                 min = -2, max = 2)$scores) -->
<!--   dtCtry$PFS.c <- as.numeric(scale(dtCtry$PFS.m, scale = F, center = T)) -->
<!--   dtCtry$PFS.z <- as.numeric(scale(dtCtry$PFS.m, scale = T)) -->
<!--   dtCtry$PFS.fa <- as.numeric(fa(dtCtry %>% dplyr::select(PFS01, PFS02, PFS03))$scores) -->

<!-- # disempowerment -->
<!--   dtCtry %>% dplyr::select(fail01, fail02, fail03) %>% psych::describe() -->
<!--   dtCtry$disemp.m <- as.numeric(scoreItems(keys=c(1,1,1), -->
<!--                             items = dtCtry %>% dplyr::select(fail01, fail02, fail03) %>% na_if(., -99), -->
<!--                                 min = -2, max = 2)$scores) -->
<!--   dtCtry$disemp.c <- as.numeric(scale(dtCtry$disemp.m, scale = F, center = T)) -->
<!--   dtCtry$disemp.z <- as.numeric(scale(dtCtry$disemp.m, scale = T)) -->
<!--   dtCtry$disemp.fa <- as.numeric(fa(dtCtry %>% dplyr::select(fail01, fail02, fail03))$scores) -->

<!-- # Well-Being -->
<!--   # need rescaling first -->
<!--     dtCtry$lifeSat <- scales::rescale(as.numeric(dtCtry$lifeSat), to = c(1,10)) -->
<!--     dtCtry$MLQ <- scales::rescale(as.numeric(dtCtry$MLQ), to = c(1,10)) -->
<!--   dtCtry %>% dplyr::select(happy, lifeSat, MLQ) %>% psych::describe() -->
<!--   dtCtry$WB.m <- as.numeric(scoreItems(keys=c(1,1,1), -->
<!--                                 items = dtCtry %>% dplyr::select(happy, lifeSat, MLQ) %>% na_if(., -99), -->
<!--                                 min = 1, max = 10)$scores) -->
<!--   dtCtry$WB.c <- as.numeric(scale(dtCtry$WB.m, scale = F, center = T)) -->
<!--   dtCtry$WB.z <- as.numeric(scale(dtCtry$WB.m, scale = T)) -->
<!--   dtCtry$WB.fa <- as.numeric(fa(dtCtry %>% dplyr::select(happy, lifeSat, MLQ))$scores) -->

<!-- # pro-Social Behavior -->
<!--   dtCtry %>% dplyr::select(starts_with("c19ProSo"), -contains("DO")) %>% psych::describe() -->
<!--   dtCtry$c19ProSo.m <- as.numeric(as.numeric(scoreItems(keys=c(1,1,1,1), -->
<!--                                 items = dtCtry %>% dplyr::select(starts_with("c19ProSo"), -contains("DO")) %>% na_if(., -99), -->
<!--                                 min = -3, max = 3)$scores)) -->
<!--   dtCtry$c19ProSo.c <- as.numeric(scale(dtCtry$c19ProSo.m, scale = F, center = T)) -->
<!--   dtCtry$c19ProSo.z <- as.numeric(scale(dtCtry$c19ProSo.m, scale = T)) -->
<!--   dtCtry$c19ProSo.fa <- as.numeric(fa(dtCtry %>% dplyr::select(starts_with("c19ProSo"), -contains("DO")))$scores) -->

<!-- ``` -->

<!-- #### Interactions -->
<!-- ```{r calcInt, echo=T, warning=F, message=F} -->
<!-- # calculate interactions for observed modeling -->
<!--   dtCtry <- dtCtry %>% -->
<!--   mutate(intPosEmoXDisemp = posEmo.c*disemp.c, -->
<!--          intNegEmoXDisemp = negEmo.c*disemp.c, -->
<!--          intPFSXDisemp = PFS.c*disemp.c, scale = F, center = T) -->
<!-- ``` -->

### Within Participant
#### wide to long
```{r}
# select relevant vars
tmp <- dtFullRed %>%
  dplyr::transmute_at(vars(matches(
    paste(c("affAnx", "affCalm", "affDepr", "affEnerg", "affNerv", "affInsp", "affRel",
            "affExh", "PFS01", "happy", "lifeSat", "c19NormShould", "c19ProSo03"), collapse = "|"), -contains("DO"))), #vars changed
    as.numeric)

# CLOSE YOUR EYES! TRIGGER WARNING! (should have named these variables better...)
tmp <- tmp %>%
  transmute(
    w00_affAnx = affAnx, w00_affCalm = affCalm, w00_affDepr = affDepr, w00_affEnerg = affEnerg, w00_affNerv = affNerv, 
    w00_affInsp = affInsp, w00_affRel = affRel, w00_affExh = affExh, w00_PFS01 = PFS01, w00_happy = happy, w00_lifeSat = lifeSat,
    w00_c19NormShould = c19NormShould, w00_c19ProSo03 = c19ProSo03,
    w01_affAnx = w1_affAnx, w01_affCalm = w1_affCalm, w01_affDepr = w1_affDepr, w01_affEnerg = w1_affEnerg, 
    w01_affNerv = w1_affNerv, w01_affInsp = w1_affInsp, w01_affRel = w1_affRel, w01_affExh = w1_affExh, w01_PFS01 = w1_PFS01,
    w01_happy = NA_real_, w01_lifeSat = w1_lifeSat, w01_c19NormShould = NA_real_, w01_c19ProSo03 = w1_c19ProSo03,
    w02_affAnx = w2_affAnx, w02_affCalm = w2_affCalm, w02_affDepr = w2_affDepr, w02_affEnerg = w2_affEnerg, 
    w02_affNerv = w2_affNerv, w02_affInsp = w2_affInsp, w02_affRel = w2_affRel, w02_affExh = w2_affExh, w02_PFS01 = w2_PFS01,
    w02_happy = NA_real_, w02_lifeSat = NA_real_, w02_c19NormShould = NA_real_, w02_c19ProSo03 = w2_c19ProSo03,
    w03_affAnx = w3_affAnx, w03_affCalm = w3_affCalm, w03_affDepr = w3_affDepr, w03_affEnerg = w3_affEnerg, 
    w03_affNerv = w3_affNerv, w03_affInsp = w3_affInsp, w03_affRel = w3_affRel, w03_affExh = w3_affExh, w03_PFS01 = w3_PFS01,
    w03_happy = NA_real_, w03_lifeSat = NA_real_, w03_c19NormShould = NA_real_, w03_c19ProSo03 = w3_c19ProSo03,
    w04_affAnx = w4_affAnx, w04_affCalm = w4_affCalm, w04_affDepr = w4_affDepr, w04_affEnerg = w4_affEnerg, 
    w04_affNerv = w4_affNerv, w04_affInsp = w4_affInsp, w04_affRel = w4_affRel, w04_affExh = w4_affExh, w04_PFS01 = w4_PFS01,
    w04_happy = w4_happy, w04_lifeSat = w4_lifeSat, w04_c19NormShould = NA_real_, w04_c19ProSo03 = w4_c19ProSo03,
    w05_affAnx = w5_affAnx, w05_affCalm = w5_affCalm, w05_affDepr = w5_affDepr, w05_affEnerg = w5_affEnerg, 
    w05_affNerv = w5_affNerv, w05_affInsp = w5_affInsp, w05_affRel = w5_affRel, w05_affExh = w5_affExh, w05_PFS01 = w5_PFS01,
    w05_happy = w5_happy, w05_lifeSat = w5_lifeSat, w05_c19NormShould = w5_c19NormShould, w05_c19ProSo03 = w5_c19ProSo03,
    w06_affAnx = w6_affAnx, w06_affCalm = w6_affCalm, w06_affDepr = w6_affDepr, w06_affEnerg = w6_affEnerg, 
    w06_affNerv = w6_affNerv, w06_affInsp = w6_affInsp, w06_affRel = w6_affRel, w06_affExh = w6_affExh, w06_PFS01 = NA_real_,
    w06_happy = NA_real_, w06_lifeSat = NA_real_, w06_c19NormShould = NA_real_, w06_c19ProSo03 = w6_c19ProSo03,
    w07_affAnx = w7_affAnx, w07_affCalm = w7_affCalm, w07_affDepr = w7_affDepr, w07_affEnerg = w7_affEnerg, 
    w07_affNerv = w7_affNerv, w07_affInsp = w7_affInsp, w07_affRel = w7_affRel, w07_affExh = w7_affExh, w07_PFS01 = NA_real_,
    w07_happy = NA_real_, w07_lifeSat = w7_lifeSat, w07_c19NormShould = NA_real_, w07_c19ProSo03 = w7_c19ProSo03,
    w08_affAnx = w8_affAnx, w08_affCalm = w8_affCalm, w08_affDepr = w8_affDepr, w08_affEnerg = w8_affEnerg, 
    w08_affNerv = w8_affNerv, w08_affInsp = w8_affInsp, w08_affRel = w8_affRel, w08_affExh = w8_affExh, w08_PFS01 = NA_real_,
    w08_happy = w8_happy, w08_lifeSat = NA_real_, w08_c19NormShould = NA_real_, w08_c19ProSo03 = w8_c19ProSo03,
    w09_affAnx = w9_affAnx, w09_affCalm = w9_affCalm, w09_affDepr = w9_affDepr, w09_affEnerg = w9_affEnerg, 
    w09_affNerv = w9_affNerv, w09_affInsp = w9_affInsp, w09_affRel = w9_affRel, w09_affExh = w9_affExh, w09_PFS01 = w9_PFS01,
    w09_happy = w9_happy, w09_lifeSat = NA_real_, w09_c19NormShould = w9_c19NormShould, w09_c19ProSo03 = w9_c19ProSo03,
    w10_affAnx = w10_affAnx, w10_affCalm = w10_affCalm, w10_affDepr = w10_affDepr, w10_affEnerg = w10_affEnerg, 
    w10_affNerv = w10_affNerv, w10_affInsp = w10_affInsp, w10_affRel = w10_affRel, w10_affExh = w10_affExh, w10_PFS01 = NA_real_,
    w10_happy = NA_real_, w10_lifeSat = NA_real_, w10_c19NormShould = NA_real_, w10_c19ProSo03 = w10_c19ProSo03,
    w11_affAnx = w11_affAnx, w11_affCalm = w11_affCalm, w11_affDepr = w11_affDepr, w11_affEnerg = w11_affEnerg, 
    w11_affNerv = w11_affNerv, w11_affInsp = w11_affInsp, w11_affRel = w11_affRel, w11_affExh = w11_affExh, w11_PFS01 = w11_PFS01,
    w11_happy = w11_happy, w11_lifeSat = w11_lifeSat, w11_c19NormShould = w11_c19NormShould, w11_c19ProSo03 = w11_c19ProSo03,
    w12_affAnx = w12_affAnx, w12_affCalm = w12_affCalm, w12_affDepr = w12_affDepr, w12_affEnerg = w12_affEnerg, 
    w12_affNerv = w12_affNerv, w12_affInsp = w12_affInsp, w12_affRel = w12_affRel, w12_affExh = w12_affExh, w12_PFS01 = w12_PFS01,
    w12_happy = w12_happy, w12_lifeSat = w12_lifeSat, w12_c19NormShould = w12_c19NormShould, w12_c19ProSo03 = w12_c19ProSo03,
    w13_affAnx = w13_affAnx, w13_affCalm = w13_affCalm, w13_affDepr = w13_affDepr, w13_affEnerg = w13_affEnerg, 
    w13_affNerv = w13_affNerv, w13_affInsp = w13_affInsp, w13_affRel = w13_affRel, w13_affExh = w13_affExh, w13_PFS01 = w13_PFS01,
    w13_happy = w13_happy, w13_lifeSat = w13_lifeSat, w13_c19NormShould = w13_c19NormShould, w13_c19ProSo03 = w13_c19ProSo03,
    w14_affAnx = w14_affAnx, w14_affCalm = w14_affCalm, w14_affDepr = w14_affDepr, w14_affEnerg = w14_affEnerg, 
    w14_affNerv = w14_affNerv, w14_affInsp = w14_affInsp, w14_affRel = w14_affRel, w14_affExh = w14_affExh, w14_PFS01 = w14_PFS01,
    w14_happy = w14_happy, w14_lifeSat = w14_lifeSat, w14_c19NormShould = w14_c19NormShould, w14_c19ProSo03 = w14_c19ProSo03,
    w15_affAnx = w15_affAnx, w15_affCalm = w15_affCalm, w15_affDepr = w15_affDepr, w15_affEnerg = w15_affEnerg, 
    w15_affNerv = w15_affNerv, w15_affInsp = w15_affInsp, w15_affRel = w15_affRel, w15_affExh = w15_affExh, w15_PFS01 = w15_PFS01,
    w15_happy = w15_happy, w15_lifeSat = w15_lifeSat, w15_c19NormShould = w15_c19NormShould, w15_c19ProSo03 = w15_c19ProSo03,
    w16_affAnx = w16_affAnx, w16_affCalm = w16_affCalm, w16_affDepr = w16_affDepr, w16_affEnerg = w16_affEnerg, 
    w16_affNerv = w16_affNerv, w16_affInsp = w16_affInsp, w16_affRel = w16_affRel, w16_affExh = w16_affExh, w16_PFS01 = w16_PFS01,
    w16_happy = w16_happy, w16_lifeSat = w16_lifeSat, w16_c19NormShould = w16_c19NormShould, w16_c19ProSo03 = w16_c19ProSo03,
    w17_affAnx = w17_affAnx, w17_affCalm = w17_affCalm, w17_affDepr = w17_affDepr, w17_affEnerg = w17_affEnerg, 
    w17_affNerv = w17_affNerv, w17_affInsp = w17_affInsp, w17_affRel = w17_affRel, w17_affExh = w17_affExh, w17_PFS01 = w17_PFS01,
    w17_happy = w17_happy, w17_lifeSat = NA_real_, w17_c19NormShould = w17_c19NormShould, w17_c19ProSo03 = w17_c19ProSo03,
    w18_affAnx = w18_affAnx, w18_affCalm = w18_affCalm, w18_affDepr = w18_affDepr, w18_affEnerg = w18_affEnerg, 
    w18_affNerv = w18_affNerv, w18_affInsp = w18_affInsp, w18_affRel = w18_affRel, w18_affExh = w18_affExh, w18_PFS01 = w18_PFS01,
    w18_happy = w18_happy, w18_lifeSat = NA_real_, w18_c19NormShould = w18_c19NormShould, w18_c19ProSo03 = w18_c19ProSo03,
    w19_affAnx = w19_affAnx, w19_affCalm = w19_affCalm, w19_affDepr = w19_affDepr, w19_affEnerg = w19_affEnerg, 
    w19_affNerv = w19_affNerv, w19_affInsp = w19_affInsp, w19_affRel = w19_affRel, w19_affExh = w19_affExh, w19_PFS01 = w19_PFS01,
    w19_happy = w19_happy, w19_lifeSat = NA_real_, w19_c19NormShould = w19_c19NormShould, w19_c19ProSo03 = w19_c19ProSo03,
    w20_affAnx = w20_affAnx, w20_affCalm = w20_affCalm, w20_affDepr = w20_affDepr, w20_affEnerg = w20_affEnerg, 
    w20_affNerv = w20_affNerv, w20_affInsp = w20_affInsp, w20_affRel = w20_affRel, w20_affExh = w20_affExh, w20_PFS01 = w20_PFS01,
    w20_happy = w20_happy, w20_lifeSat = w20_lifeSat, w20_c19NormShould = w20_c19NormShould, w20_c19ProSo03 = w20_c19ProSo03,
    w21_affAnx = w21_affAnx, w21_affCalm = w21_affCalm, w21_affDepr = w21_affDepr, w21_affEnerg = w21_affEnerg, 
    w21_affNerv = w21_affNerv, w21_affInsp = w21_affInsp, w21_affRel = w21_affRel, w21_affExh = w21_affExh, w21_PFS01 = w21_PFS01,
    w21_happy = w21_happy, w21_lifeSat = w21_lifeSat, w21_c19NormShould = w21_c19NormShould, w21_c19ProSo03 = w21_c19ProSo03,
    w22_affAnx = w22_affAnx, w22_affCalm = w22_affCalm, w22_affDepr = w22_affDepr, w22_affEnerg = w22_affEnerg, 
    w22_affNerv = w22_affNerv, w22_affInsp = w22_affInsp, w22_affRel = w22_affRel, w22_affExh = w22_affExh, w22_PFS01 = w22_PFS01,
    w22_happy = w22_happy, w22_lifeSat = w22_lifeSat, w22_c19NormShould = w22_c19NormShould, w22_c19ProSo03 = w22_c19ProSo03
    )

tmp$PPID <- dtFullRed$PPID
tmp <- data.table::data.table(tmp)

library(data.table)
dtLong <- data.table::melt.data.table(
  data = tmp, 
  id.vars = "PPID",
  measure.vars = patterns( # cannot access patterns directly! need to load data.table library!!!
    affAnx = "affAnx",
    affCalm = "affCalm",
    affDepr = "affDepr",
    affEnerg = "affEnerg",
    affNerv = "affNerv",
    affInsp = "affInsp",
    affRel = "affRel",
    affExh = "affExh",
    PFS01 = "PFS01",
    happy = "happy",
    lifeSat = "lifeSat",
    c19NormShould = "c19NormShould", 
    # c19ProSo01 = "c19ProSo01",
    c19ProSo03 = "c19ProSo03"),
  variable.name = "wave"
  )
rm(tmp)

# add non-longitudinal variables to dataset
tmp <- dtFullRed %>%
  select(PPID,
         coded_country)

dtLong <- dtLong %>%
  dplyr::left_join(tmp, by = "PPID"); rm(tmp)
```

#### Scales
```{r, echo=FALSE}

# input = dtLong
# waveNum = 2
# varNames = c("affAnx", "affDepr", "affNerv", "affExh")

# load function for averaging per wave
long_scale_calc <- function(input, waveNum, varNames) {
  
  input <- input %>%
  filter(wave == waveNum) %>%
  select(contains(varNames))

# check whether minimum is the same across input columns
  testMin = list()
  testMin$test <- input %>%
    summarise_each(funs(min(., na.rm = T)))%>%
    table()
  testMin$num <- input %>%
    summarise_each(funs(min(., na.rm = T))) %>%
    as.numeric()
  ifelse(ncol(testMin$test) & nrow(testMin$test) == 1, 
         print("All input variables have the same minimum"), 
         stop("Warning: Minimum seems to differ across input variables"))

# check whether maximum is the same across input columns
  testMax = list()
  testMax$test <- input %>%
    summarise_each(funs(max(., na.rm = T)))%>%
    table()
  testMax$num <- input %>%
    summarise_each(funs(max(., na.rm = T))) %>%
    as.numeric()
  ifelse(ncol(testMax$test) & nrow(testMax$test) == 1, 
         print("All input variables have the same maximum"), 
         stop("Warning: Maximum seems to differ across input variables"))
  
# calculate scale
  scaleCalc <- scoreItems(keys=rep(1, ncol(input)),
                          items = input,
                          min = testMin$num[1], max = testMax$num[1],
                          impute = "none")
  
  print(paste("Alpha for the following items in wave ", waveNum, ":", sep = ""))
  print(varNames)
  print(round(scaleCalc$alpha, 2))
  
  output <- round(as.numeric(scaleCalc$scores), 3)

  return(output)
  rm(testMin, testMax, scaleCalc, output, input)
}
```

##### calculate scales
```{r, echo=FALSE}
# ---------------- positive emotion-----------------
# create df for filling
  tmp <- data.table(matrix(NA, nrow = nrow(dtFullRed), ncol = 23))

# calculate scale per wave
  for (waveNum in 1:max(as.numeric(dtLong$wave))) {
    tmp[,waveNum] <- long_scale_calc(input = dtLong, waveNum = waveNum, varNames = c("affCalm", "affEnerg", "affInsp", "affRel"))
  }
  tmp$PPID <- dtFullRed$PPID

# turn into long format again
  tmp2 <- data.table::melt.data.table(
    data = tmp, 
    id.vars = "PPID",
    variable.name = "wave",
    value.name = "scale"
    )
# add to already existing dataframe of long data
  dtLong$posEmo <- as.numeric(tmp2$scale)
  rm(tmp, tmp2)

# ---------------- negative emotion-----------------
# create df for filling
  tmp <- data.table(matrix(NA, nrow = nrow(dtFullRed), ncol = 23))

# calculate scale per wave
  for (waveNum in 1:max(as.numeric(dtLong$wave))) {
    tmp[,waveNum] <- long_scale_calc(input = dtLong, waveNum = waveNum, varNames = c("affAnx", "affDepr", "affNerv", "affExh"))
  }
  tmp$PPID <- dtFullRed$PPID

# turn into long format again
  tmp2 <- data.table::melt.data.table(
    data = tmp, 
    id.vars = "PPID",
    variable.name = "wave",
    value.name = "scale"
    )
# add to already existing dataframe of long data
  dtLong$negEmo <- as.numeric(tmp2$scale)
  rm(tmp, tmp2)
  
dtLong[dtLong == "NaN"] <- NA
```

#### create centered variables (center within clsuter)
https://kzee.github.io/Centering_Demo.html (blml::isolate unfortunately does not work)
```{r}
# calculate mean and sds per participant
dtLong <- dtLong %>%
  group_by(PPID) %>%
  mutate(
    negEmo_mean = mean(negEmo, na.rm = T),
    negEmo_sd = sd(negEmo, na.rm = T),
    posEmo_mean = mean(posEmo, na.rm = T),
    posEmo_sd = sd(posEmo, na.rm = T),
    PFS01_mean = mean(PFS01, na.rm = T),
    PFS01_sd = sd(PFS01, na.rm = T),
    c19NormShould_mean = mean(c19NormShould, na.rm = T),
    c19NormShould_sd = sd(c19NormShould, na.rm = T),
    happy_mean = mean(happy, na.rm = T),
    happy_sd = sd(happy, na.rm = T),
    c19ProSo03_mean = mean(c19ProSo03, na.rm = T),
    c19ProSo03_sd = sd(c19ProSo03, na.rm = T)
  ) %>%
  ungroup()

# calculate mean and sds per country
dtLong <- dtLong %>%
  group_by(coded_country) %>%
  mutate(
    negEmoCountry_mean = mean(negEmo_mean, na.rm = T),
    negEmoCountry_sd = sd(negEmo_mean, na.rm = T),
    posEmoCountry_mean = mean(posEmo_mean, na.rm = T),
    posEmoCoutry_sd = sd(posEmo_mean, na.rm = T),
    PFS01Country_mean = mean(PFS01_mean, na.rm = T),
    PFS01Country_sd = sd(PFS01_mean, na.rm = T),
    c19NormShouldCountry_mean = mean(c19NormShould_mean, na.rm = T),
    c19NormShouldCountry_sd = sd(c19NormShould_mean, na.rm = T),
    happyCountry_mean = mean(happy_mean, na.rm = T),
    happyCountry_sd = sd(happy_mean, na.rm = T),
    c19ProSo03Country_mean = mean(c19ProSo03_mean, na.rm = T),
    c19ProSo03Country_sd = sd(c19ProSo03_mean, na.rm = T),
  ) %>%
  ungroup()


# center within (for grand mean centering or between-person centering see above link)
dtLong <- dtLong %>%
  ungroup() %>%
  mutate(
    negEmoCtry_c = scale(negEmoCountry_mean, center = T, scale = F),
    posEmoCtry_c = scale(posEmoCountry_mean, center = T, scale = F),
    c19NormShouldCtry_c = scale(c19NormShouldCountry_mean, center = T, scale = F),
    PFSCtry_c = scale(PFS01Country_mean, center = T, scale = F),
    WBCtry_c = scale(happyCountry_mean, center = T, scale = F),
    negEmoPP_c = scale(negEmo_mean, center = T, scale = F),
    posEmoPP_c = scale(posEmo_mean, center = T, scale = F),
    c19NormShouldPP_c = scale(c19NormShould_mean, center = T, scale = F),
    PFSPP_c = scale(PFS01_mean, center = T, scale = F),
    WBPP_c = scale(happy_mean, center = T, scale = F),
    negEmo_c = scale(negEmo, center = T, scale = F),
    posEmo_c = scale(posEmo, center = T, scale = F),
    c19NormShould_c = scale(c19NormShould, center = T, scale = F),
    PFS_c = scale(PFS01, center = T, scale = F),
    WB_c = scale(happy, center = T, scale = F),
    negEmo_cw = negEmo-negEmo_mean,
    posEmo_cw = posEmo-posEmo_mean,
    c19NormShould_cw = c19NormShould-c19NormShould_mean,
    PFS_cw = PFS01 - PFS01_mean,
    WB_cw = happy-happy_mean,
    negEmoPP_cw = negEmo_mean-negEmoCountry_mean,
    posEmoPP_cw = posEmo_mean-posEmoCountry_mean,
    c19NormShouldPP_cw = c19NormShould_mean-c19NormShouldCountry_mean,
    PFSPP_cw =  PFS01_mean-happyCountry_mean,
    WBPP_cw = happy_mean-mean(happy_mean, na.rm = T),
    negEmoCtry_cw = negEmoCountry_mean-mean(negEmoCountry_mean, na.rm = T),
    posEmoCtry_cw = posEmoCountry_mean-mean(posEmoCountry_mean, na.rm = T),
    c19NormShouldCtry_cw = c19NormShouldCountry_mean-mean(c19NormShouldCountry_mean, na.rm = T),
    PFSCtry_cw =  PFS01Country_mean-mean(PFS01Country_mean, na.rm = T),
    WBCtry_cw = happyCountry_mean-mean(happyCountry_mean, na.rm = T),
    WB = happy,
    c19ProSo_cw = c19ProSo03-c19ProSo03_mean
  )
```

# Analysis Longitudinal
Only looking at contemporaneous effects (nothing lagged/causal)
Not causal/lagged because measurement points to different and too long apart from each other (see autocorrelation)

## Multilevel (Group mean centering)
CMC quite useful when within-cluster and between-cluster slopes may differ and one is mainly interesting in the within-cluster slope (based on Raudenbush and Bryk). As we see (similar to  Hamaker & Grasman, 2014) grand-mean centering (see above) results in larger effects as within-cluster centering biases effects to be smaller (more conservative and still valid)
### Well-Being
http://www.alexanderdemos.org/Mixed5.html#plot_final_results_(fixed_effects_only)

First question: Do we need multilevel modeling? Run intercept only model! If amount of variance on level 2/3 is significant multilevel modeling is handy (but taking into account nestedness almost always is).
```{r}
lm_lv0 <- lm(WB ~ 1, # each person can have its own intercept relative to the country
                  data = dtLong)
ana_lv0 <- lme4::lmer(WB ~ 1 + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

anova(ana_lv0, lm_lv0)
summary(ana_lv0)
performance::icc(ana_lv0)

# calculate the ACF for lags between 1 and 50 (inclusive); probably not too important due to the large amount of missingness
tmp <- dtLong %>% # sort after participant (if we have autocorrelation every 25 measurement should repeat)
  arrange(PPID)

autocorrelation <- acf(dtLong$WB, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(tmp, autocorrelation)

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv0)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

Second step: Add all level 1 predictors
```{r}
ana_lv1 <- lme4::lmer(WB ~ negEmo_cw + posEmo_cw + PFS_cw + c19NormShould_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv1)
performance::icc(ana_lv1)

# variances
var_ana_lv1 <- as.data.frame(lme4::VarCorr(ana_lv1))
var_ana_lv0 <- as.data.frame(lme4::VarCorr(ana_lv0))
var_ana_lv0
var_ana_lv1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv1)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation, var_ana_lv0, var_ana_lv1)
```

Third step: Add all level 1 predictors and their interactions
```{r}
ana_lv1_int <- lme4::lmer(WB ~ negEmo_cw*c19NormShould_cw + posEmo_cw*c19NormShould_cw + PFS_cw*c19NormShould_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv1_int)
performance::icc(ana_lv1_int)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv1_int)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### level 2 predictors
If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016)
```{r}
ana_lv12 <- lme4::lmer(WB ~ negEmo_cw + posEmo_cw + PFS_cw + c19NormShould_cw + 
                         negEmoPP_cw + posEmoPP_cw + PFSPP_cw + c19NormShouldPP_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv12)
performance::icc(ana_lv12)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv12)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

```{r}
ana_lv12_int <- lme4::lmer(WB ~ negEmo_cw*c19NormShould_cw + posEmo_cw*c19NormShould_cw + PFS_cw*c19NormShould_cw + 
                             negEmoPP_cw*c19NormShouldPP_cw + posEmoPP_cw*c19NormShouldPP_cw + PFSPP_cw*c19NormShouldPP_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv12_int)
performance::icc(ana_lv12_int)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv12_int)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)

# interactiosn
# sjPlot::plot_model(ana_lv12_int, type = "int", mdrt.values = "meansd")
# 
# interactions::sim_slopes(ana_lv12_int, pred = "posEmo_cw", modx = "c19NormShould_cw", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# interactions::sim_slopes(ana_lv12_int, pred = "negEmo_cw", modx = "c19NormShould_cw", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# interactions::sim_slopes(ana_lv12_int, pred = "PFS_cw", modx = "c19NormShould_cw", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# interactions::sim_slopes(ana_lv12_int, pred = "posEmoPP_cw", modx = "c19NormShouldPP_cw", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# interactions::sim_slopes(ana_lv12_int, pred = "negEmoPP_cw", modx = "c19NormShouldPP_cw", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# interactions::sim_slopes(ana_lv12_int, pred = "PFSPP_cw", modx = "c19NormShouldPP_cw", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)

```
#### level 3 predictors
If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016)
```{r}
ana_lv123 <- lme4::lmer(WB ~ negEmo_cw + posEmo_cw + PFS_cw + c19NormShould_cw + 
                          negEmoPP_cw + posEmoPP_cw + PFSPP_cw + c19NormShouldPP_cw + 
                      negEmoCtry_cw + posEmoCtry_cw + PFSCtry_cw + c19NormShouldCtry_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv123)
performance::icc(ana_lv123)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv123)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

```{r}
ana_lv123_int <- lme4::lmer(WB ~ negEmo_cw*c19NormShould_cw + posEmo_cw*c19NormShould_cw + PFS_cw*c19NormShould_cw + 
                              negEmoPP_cw*c19NormShouldPP_cw + posEmoPP_cw*c19NormShouldPP_cw + PFSPP_cw*c19NormShouldPP_cw +
                      negEmoCtry_cw*c19NormShouldCtry_cw + posEmoCtry_cw*c19NormShouldCtry_cw + PFSCtry_cw*c19NormShouldCtry_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv123_int)
performance::icc(ana_lv123_int)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv123_int)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### cross-level interactions (1,2)
```{r}
ana_lv123_intCrossAll <- lme4::lmer(WB ~ negEmo_cw*c19NormShould_cw + posEmo_cw*c19NormShould_cw + PFS_cw*c19NormShould_cw + 
                             negEmoPP_cw*c19NormShouldPP_cw + posEmoPP_cw*c19NormShouldPP_cw + PFSPP_cw*c19NormShouldPP_cw +  
                             negEmo_cw*c19NormShouldPP_cw + posEmo_cw*c19NormShouldPP_cw + PFS_cw*c19NormShouldPP_cw +  
                             negEmoCtry_cw*c19NormShouldCtry_cw + posEmoCtry_cw*c19NormShouldCtry_cw + PFSCtry_cw*c19NormShouldCtry_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

ana_lv123_intCrossOnly <- lme4::lmer(WB ~ negEmo_cw + posEmo_cw + PFS_cw + c19NormShould_cw +
                             negEmoPP_cw + posEmoPP_cw + PFSPP_cw +  c19NormShouldPP_cw +
                             negEmo_cw*c19NormShouldPP_cw + posEmo_cw*c19NormShouldPP_cw + PFS_cw*c19NormShouldPP_cw +  
                             negEmoCtry_cw + posEmoCtry_cw + PFSCtry_cw + c19NormShouldCtry_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv123_intCrossAll)
performance::icc(ana_lv123_intCrossOnly)
summary(ana_lv123_intCrossAll)
performance::icc(ana_lv123_intCrossOnly)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
# saveRes <- residuals(ana_lv123_intCross)
# plot(saveRes)
# autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
# autocorrelation; rm(saveRes, autocorrelation)
```
#### understand interactions
```{r}
# positive emotions (we save path A for later); important for indirect effects as well
tmp_posEmo <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "posEmo_cw", modx = "c19NormShould_cw", 
                         johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_negEmo <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "negEmo_cw", modx = "c19NormShould_cw", 
                         johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_PFS <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "PFS_cw", modx = "c19NormShould_cw", 
                         johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_posEmoPP <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "posEmoPP_cw", modx = "c19NormShouldPP_cw", 
                         johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_posEmoPP
tmp_negEmoPP <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "negEmoPP_cw", modx = "c19NormShouldPP_cw", 
                         johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_PFSPP <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "PFSPP_cw", modx = "c19NormShouldPP_cw", 
                         johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_PFSPP
tmp_posEmoCross <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "posEmo_cw", modx = "c19NormShouldPP_cw", 
                         johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_posEmoCross
tmp_negEmoCross <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "negEmo_cw", modx = "c19NormShouldPP_cw", 
                         johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_PFSCross <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "PFS_cw", modx = "c19NormShouldPP_cw", 
                         johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_PFSCross
tmp_posEmoCtry <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "posEmoCtry_cw", modx = "c19NormShouldCtry_cw", 
                         johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_negEmoCtry <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "negEmoCtry_cw", modx = "c19NormShouldCtry_cw", 
                         johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_PFSCtry <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "PFSCtry_cw", modx = "c19NormShouldCtry_cw", 
                         johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
```

#### save for indirect effects (A path)
http://www.quantpsy.org/medmc/medmc.htm
Selig, J. P., & Preacher, K. J. (2008, June). Monte Carlo method for assessing mediation: An interactive tool for creating confidence intervals for indirect effects [Computer software]. Available from http://quantpsy.org/.
-Run a regression analysis (or path analysis, SEM, etc.) with the IV predicting the mediator. This will give a.
-Run a regression analysis with the IV and mediator predicting the DV. This will give b.
-If you use SEM, path analysis, multilevel modeling, or some other multivariate method to obtain both a and b from a single model, then var(a), var(b), and cov(a,b) can be found in the asymptotic covariance matrix of the parameter estimates. If you use regression to obtain a and b in separate steps, then var(a) and var(b) are simply the squared standard errors, and cov(a,b) = 0.

```{r}
paths_WB <- data.frame(
  posEmo_plus1c19NormShouldSD_A = tmp_posEmo$slopes$Est.[1],
  posEmo_plus1c19NormShouldSD_varA = tmp_posEmo$slopes$S.E.[1],
  posEmo_minus1c19NormShouldSD_A = tmp_posEmo$slopes$Est.[3],
  posEmo_minus1c19NormShouldSD_varA = tmp_posEmo$slopes$S.E.[3],
  negEmo_plus1c19NormShouldSD_A = tmp_negEmo$slopes$Est.[1],
  negEmo_plus1c19NormShouldSD_varA = tmp_negEmo$slopes$S.E.[1],
  negEmo_minus1c19NormShouldSD_A = tmp_negEmo$slopes$Est.[3],
  negEmo_minus1c19NormShouldSD_varA = tmp_negEmo$slopes$S.E.[3],
  PFS_plus1c19NormShouldSD_A = tmp_PFS$slopes$Est.[1],
  PFS_plus1c19NormShouldSD_varA = tmp_PFS$slopes$S.E.[1],
  PFS_minus1c19NormShouldSD_A = tmp_PFS$slopes$Est.[3],
  PFS_minus1c19NormShouldSD_varA = tmp_PFS$slopes$S.E.[3],
  posEmoPP_plus1c19NormShouldSD_A = tmp_posEmoPP$slopes$Est.[1],
  posEmoPP_plus1c19NormShouldSD_varA = tmp_posEmoPP$slopes$S.E.[1],
  posEmoPP_minus1c19NormShouldSD_A = tmp_posEmoPP$slopes$Est.[3],
  posEmoPP_minus1c19NormShouldSD_varA = tmp_posEmoPP$slopes$S.E.[3],
  negEmoPP_plus1c19NormShouldSD_A = tmp_negEmoPP$slopes$Est.[1],
  negEmoPP_plus1c19NormShouldSD_varA = tmp_negEmoPP$slopes$S.E.[1],
  negEmoPP_minus1c19NormShouldSD_A = tmp_negEmoPP$slopes$Est.[3],
  negEmoPP_minus1c19NormShouldSD_varA = tmp_negEmoPP$slopes$S.E.[3],
  PFSPP_plus1c19NormShouldSD_A = tmp_PFSPP$slopes$Est.[1],
  PFSPP_plus1c19NormShouldSD_varA = tmp_PFSPP$slopes$S.E.[1],
  PFSPP_minus1c19NormShouldSD_A = tmp_PFSPP$slopes$Est.[3],
  PFSPP_minus1c19NormShouldSD_varA = tmp_PFSPP$slopes$S.E.[3],
  posEmoCross_plus1c19NormShouldSD_A = tmp_posEmoCross$slopes$Est.[1],
  posEmoCross_plus1c19NormShouldSD_varA = tmp_posEmoCross$slopes$S.E.[1],
  posEmoCross_minus1c19NormShouldSD_A = tmp_posEmoCross$slopes$Est.[3],
  posEmoCross_minus1c19NormShouldSD_varA = tmp_posEmoCross$slopes$S.E.[3],
  negEmoCross_plus1c19NormShouldSD_A = tmp_negEmoCross$slopes$Est.[1],
  negEmoCross_plus1c19NormShouldSD_varA = tmp_negEmoCross$slopes$S.E.[1],
  negEmoCross_minus1c19NormShouldSD_A = tmp_negEmoCross$slopes$Est.[3],
  negEmoCross_minus1c19NormShouldSD_varA = tmp_negEmoCross$slopes$S.E.[3],
  PFSCross_plus1c19NormShouldSD_A = tmp_PFSCross$slopes$Est.[1],
  PFSCross_plus1c19NormShouldSD_varA = tmp_PFSCross$slopes$S.E.[1],
  PFSCross_minus1c19NormShouldSD_A = tmp_PFSCross$slopes$Est.[3],
  PFSCross_minus1c19NormShouldSD_varA = tmp_PFSCross$slopes$S.E.[3],
  posEmoCtry_plus1c19NormShouldSD_A = tmp_posEmoCtry$slopes$Est.[1],
  posEmoCtry_plus1c19NormShouldSD_varA = tmp_posEmoCtry$slopes$S.E.[1],
  posEmoCtry_minus1c19NormShouldSD_A = tmp_posEmoCtry$slopes$Est.[3],
  posEmoCtry_minus1c19NormShouldSD_varA = tmp_posEmoCtry$slopes$S.E.[3],
  negEmoCtry_plus1c19NormShouldSD_A = tmp_negEmoCtry$slopes$Est.[1],
  negEmoCtry_plus1c19NormShouldSD_varA = tmp_negEmoCtry$slopes$S.E.[1],
  negEmoCtry_minus1c19NormShouldSD_A = tmp_negEmoCtry$slopes$Est.[3],
  negEmoCtry_minus1c19NormShouldSD_varA = tmp_negEmoCtry$slopes$S.E.[3],
  PFSCtry_plus1c19NormShouldSD_A = tmp_PFSCtry$slopes$Est.[1],
  PFSCtry_plus1c19NormShouldSD_varA = tmp_PFSCtry$slopes$S.E.[1],
  PFSCtry_minus1c19NormShouldSD_A = tmp_PFSCtry$slopes$Est.[3],
  PFSCtry_minus1c19NormShouldSD_varA = tmp_PFSCtry$slopes$S.E.[3]
)

rm(list=ls(pattern="^tmp"))
```


#### save tables
```{r}
 stargazer::stargazer(ana_lv0, ana_lv1, ana_lv1_int, ana_lv12, ana_lv12_int, ana_lv123, ana_lv123_int, 
                      ana_lv123_intCrossAll, ana_lv123_intCrossOnly,
                summary=FALSE,
                type='html',
                rownames = TRUE,
                initial.zero=FALSE,
                ci = TRUE,
                digits=3,
                digits.extra = 3,
                order = c(1, 17, 21, 2, 18, 22, 3, 19, 23, 16, 20, 24, 4, 7, 10, 13, 5, 8, 11, 14, 6, 9, 12, 15),
                title='WellBeing Group Mean Centering Analyses',
                column.labels = c("randomInt", "level1", "level1+int", "level1-2", "level1-2+int", "level1-3", "level1-3+int",
                                  "level 1-3+crossIntAll", "level 1-3+crossIntOnly"),
                dep.var.labels = c("Well-Being"),
                out="output/tables/Longitudinal/Norms/WB_CW.html")

# stargazer::stargazer(ana_lv123_intCrossAll,
#                 summary=FALSE,
#                 type='html',
#                 rownames = TRUE,
#                 initial.zero=TRUE,
#                 ci = TRUE,
#                 digits=3,
#                 digits.extra = 3,
#                 p.auto = T,
#                 title='WellBeing Analyses',
#                 # column.labels = c(),
#                 dep.var.labels = c("Well-Being"),
#                 out="output/tables/oldWB_CW.html")

WB_cw_out <- mlm_summary_out(ana_lv123_intCrossAll)

stargazer::stargazer(WB_cw_out, 
                     out="output/tables/Longitudinal/Norms/WB_CW_relOnly.html",
                     summary=FALSE,
                     type='html',
                     digits=3,
                     digits.extra = 3,
                     title='WellBeing Group Mean Centering Analyses')

rm(list=ls(pattern="^ana"))
```

### Pro-Sociality (no well-being)
http://www.alexanderdemos.org/Mixed5.html#plot_final_results_(fixed_effects_only)

We have `r nrow(dtLong)-sum(is.na(dtLong$affAnx))` total measurements.
First question: Do we need multilevel modeling? Run intercept only model! If amount of variance on level 2/3 is significant multilevel modeling is handy (but taking into account nestedness almost always is).
```{r}
lm_0 <- lm(c19ProSo03 ~ 1, # each person can have its own intercept relative to the country
                  data = dtLong)
ana_lv0 <- lme4::lmer(c19ProSo03 ~ 1 + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

anova(ana_lv0, lm_0)
summary(ana_lv0)
performance::icc(ana_lv0)

# calculate the ACF for lags between 1 and 50 (inclusive); probably not too important due to the large amount of missingness
tmp <- dtLong %>% # sort after participant (if we have autocorrelation every 25 measurement should repeat)
  arrange(PPID)

autocorrelation <- acf(dtLong$c19ProSo03, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(tmp, autocorrelation)

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv0)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

Second step: Add all level 1 predictors
```{r}
ana_lv1 <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw + c19NormShould_cw + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv1)
performance::icc(ana_lv1)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana_lv1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana_lv0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv1)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

Third step: Add all level 1 predictors and their interactions
```{r}
ana_lv1_int <- lme4::lmer(c19ProSo03 ~ negEmo_cw*c19NormShould_cw + posEmo_cw*c19NormShould_cw + PFS_cw*c19NormShould_cw + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv1_int)
performance::icc(ana_lv1_int)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana_lv1_int))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv1_int)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### level 2 predictors
If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016)
```{r}
ana_lv12 <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw + c19NormShould_cw +  
                         negEmoPP_cw + posEmoPP_cw + PFSPP_cw + c19NormShouldPP_cw + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv12)
performance::icc(ana_lv12)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv12)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

```{r}
ana_lv12_int <- lme4::lmer(c19ProSo03 ~ negEmo_cw*c19NormShould_cw + posEmo_cw*c19NormShould_cw + PFS_cw*c19NormShould_cw + 
                             negEmoPP_cw*c19NormShouldPP_cw + posEmoPP_cw*c19NormShouldPP_cw + PFSPP_cw*c19NormShouldPP_cw +  
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv12_int)
performance::icc(ana_lv12_int)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv12_int)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)

# interactiosn
# sjPlot::plot_model(ana_lv12_int, type = "int", mdrt.values = "meansd")
# 
# interactions::sim_slopes(ana_lv12_int, pred = "posEmo_cw", modx = "c19NormShould_cw", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# interactions::sim_slopes(ana_lv12_int, pred = "negEmo_cw", modx = "c19NormShould_cw", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# interactions::sim_slopes(ana_lv12_int, pred = "PFS_cw", modx = "c19NormShould_cw", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# interactions::sim_slopes(ana_lv12_int, pred = "posEmoPP_cw", modx = "c19NormShouldPP_cw", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# interactions::sim_slopes(ana_lv12_int, pred = "negEmoPP_cw", modx = "c19NormShouldPP_cw", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# interactions::sim_slopes(ana_lv12_int, pred = "PFSPP_cw", modx = "c19NormShouldPP_cw", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
```

#### level 3 predictors
If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016)
```{r}
ana_lv123 <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw + c19NormShould_cw +  
                      negEmoPP_cw + posEmoPP_cw + PFSPP_cw + c19NormShouldPP_cw + 
                      negEmoCtry_cw + posEmoCtry_cw + PFSCtry_cw + c19NormShouldCtry_cw + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv123)
performance::icc(ana_lv123)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv123)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

```{r}
ana_lv123_int <- lme4::lmer(c19ProSo03 ~ negEmo_cw*c19NormShould_cw + posEmo_cw*c19NormShould_cw + PFS_cw*c19NormShould_cw +  
                      negEmoPP_cw*c19NormShouldPP_cw + posEmoPP_cw*c19NormShouldPP_cw + PFSPP_cw*c19NormShouldPP_cw + 
                      negEmoCtry_cw*c19NormShouldCtry_cw + posEmoCtry_cw*c19NormShouldCtry_cw + PFSCtry_cw*c19NormShouldCtry_cw +  
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv123_int)
performance::icc(ana_lv123_int)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv123_int)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### cross-level interactions (1,2)
```{r}
ana_lv123_intCrossAll <- lme4::lmer(c19ProSo03 ~ negEmo_cw*c19NormShould_cw + posEmo_cw*c19NormShould_cw + PFS_cw*c19NormShould_cw + 
                             negEmoPP_cw*c19NormShouldPP_cw + posEmoPP_cw*c19NormShouldPP_cw + PFSPP_cw*c19NormShouldPP_cw +  
                             negEmo_cw*c19NormShouldPP_cw + posEmo_cw*c19NormShouldPP_cw + PFS_cw*c19NormShouldPP_cw +  
                             negEmoCtry_cw*c19NormShouldCtry_cw + posEmoCtry_cw*c19NormShouldCtry_cw + PFSCtry_cw*c19NormShouldCtry_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

ana_lv123_intCrossOnly <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw + c19NormShould_cw +
                             negEmoPP_cw + posEmoPP_cw + PFSPP_cw +  c19NormShouldPP_cw +
                             negEmo_cw*c19NormShouldPP_cw + posEmo_cw*c19NormShouldPP_cw + PFS_cw*c19NormShouldPP_cw +  
                             negEmoCtry_cw + posEmoCtry_cw + PFSCtry_cw + c19NormShouldCtry_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv123_intCrossAll)
performance::icc(ana_lv123_intCrossOnly)
summary(ana_lv123_intCrossAll)
performance::icc(ana_lv123_intCrossOnly)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
# saveRes <- residuals(ana_lv123_intCross)
# plot(saveRes)
# autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
# autocorrelation; rm(saveRes, autocorrelation)

# interactiosn
# sjPlot::plot_model(ana_lv123_intCross, type = "int", mdrt.values = "meansd")
# 
# interactions::sim_slopes(ana_lv123_intCross, pred = "posEmo_c", modx = "c19NormShould_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# interactions::sim_slopes(ana_lv123_intCross, pred = "negEmo_c", modx = "c19NormShould_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# interactions::sim_slopes(ana_lv123_intCross, pred = "PFS_c", modx = "c19NormShould_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# interactions::sim_slopes(ana_lv123_intCross, pred = "posEmoPP_c", modx = "c19NormShouldPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# interactions::sim_slopes(ana_lv123_intCross, pred = "negEmoPP_c", modx = "c19NormShouldPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# interactions::sim_slopes(ana_lv123_intCross, pred = "PFSPP_c", modx = "c19NormShouldPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
```

#### save tables
```{r}
 stargazer::stargazer(ana_lv0, ana_lv1, ana_lv1_int, ana_lv12, ana_lv12_int, ana_lv123, ana_lv123_int, 
                      ana_lv123_intCrossAll, ana_lv123_intCrossOnly,
                summary=FALSE,
                type='html',
                rownames = TRUE,
                initial.zero=FALSE,
                ci = TRUE,
                digits=2,
                digits.extra = 2,
                order = c(1, 17, 21, 2, 18, 22, 3, 19, 23, 16, 20, 24, 4, 7, 10, 13, 5, 8, 11, 14, 6, 9, 12, 15),
                title='ProSocial Group Mean Centering Analyses',
                column.labels = c("randomInt", "level1", "level1+int", "level1-2", "level1-2+int", "level1-3", "level1-3+int"),
                dep.var.labels = c("ProSocial"),
                out="output/tables/Longitudinal/Norms/proSo_noWellBeing_CW.html")

stargazer::stargazer(ana_lv0, ana_lv1, ana_lv1_int, ana_lv12, ana_lv12_int, ana_lv123, ana_lv123_int, 
                      ana_lv123_intCrossAll, ana_lv123_intCrossOnly,
                summary=FALSE,
                type='html',
                rownames = TRUE,
                initial.zero=FALSE,
                ci = TRUE,
                digits=2,
                digits.extra = 2,
                # order = c(1, 14, 18, 2, 15, 19, 3, 16, 20),
                title='ProSocial Group Mean Centering Analyses',
                column.labels = c("randomInt", "level1", "level1+int", "level1-2", "level1-2+int", "level1-3", "level1-3+int"),
                dep.var.labels = c("ProSocial"),
                out="output/tables/Longitudinal/Norms/proSo_noWellBeing_CW.html")

proSo_noWellBeing_CW_out <- mlm_summary_out(ana_lv123_intCrossAll)

stargazer::stargazer(proSo_noWellBeing_CW_out, 
                     out="output/tables/Longitudinal/Norms/proSo_noWellBeing_CW_relOnly.html",
                     summary=FALSE,
                     type='html',
                     digits=3,
                     digits.extra = 3,
                     title='ProSocial Group Mean Centering Analyses (no wellbeing)')

rm(list=ls(pattern="^ana"))
```

### Pro-Sociality (controlling for Well-Being)
http://www.alexanderdemos.org/Mixed5.html#plot_final_results_(fixed_effects_only)

We have `r nrow(dtLong)-sum(is.na(dtLong$affAnx))` total measurements.
First question: Do we need multilevel modeling? Run intercept only model! If amount of variance on level 2/3 is significant multilevel modeling is handy (but taking into account nestedness almost always is).
```{r}
lm_0 <- lm(c19ProSo03 ~ 1, # each person can have its own intercept relative to the country
                  data = dtLong)
ana_lv0 <- lme4::lmer(c19ProSo03 ~ 1 + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

anova(ana_lv0, lm_0)
summary(ana_lv0)
performance::icc(ana_lv0)

# calculate the ACF for lags between 1 and 50 (inclusive); probably not too important due to the large amount of missingness
tmp <- dtLong %>% # sort after participant (if we have autocorrelation every 25 measurement should repeat)
  arrange(PPID)

autocorrelation <- acf(dtLong$c19ProSo03, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(tmp, autocorrelation)

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv0)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

Second step: Add all level 1 predictors
```{r}
ana_lv1 <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw + c19NormShould_cw + WB_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv1)
performance::icc(ana_lv1)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana_lv1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana_lv0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv1)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

Third step: Add all level 1 predictors and their interactions
```{r}
ana_lv1_int <- lme4::lmer(c19ProSo03 ~ negEmo_cw*c19NormShould_cw + posEmo_cw*c19NormShould_cw + PFS_cw*c19NormShould_cw + WB_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv1_int)
performance::icc(ana_lv1_int)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana_lv1_int))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv1_int)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### level 2 predictors
If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016)
```{r}
ana_lv12 <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw + c19NormShould_cw + WB_cw + 
                         negEmoPP_cw + posEmoPP_cw + PFSPP_cw + c19NormShouldPP_cw + WBPP_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv12)
performance::icc(ana_lv12)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv12)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

```{r}
ana_lv12_int <- lme4::lmer(c19ProSo03 ~ negEmo_cw*c19NormShould_cw + posEmo_cw*c19NormShould_cw + PFS_cw*c19NormShould_cw + WB_cw*c19NormShould_cw + 
                             negEmoPP_cw*c19NormShouldPP_cw + posEmoPP_cw*c19NormShouldPP_cw + PFSPP_cw*c19NormShouldPP_cw + WBPP_cw*c19NormShouldPP_cw + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv12_int)
performance::icc(ana_lv12_int)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv12_int)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### level 3 predictors
If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016)
```{r}
ana_lv123 <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw + c19NormShould_cw + WB_cw + 
                      negEmoPP_cw + posEmoPP_cw + PFSPP_cw + c19NormShouldPP_cw + WBPP_cw +
                      negEmoCtry_cw + posEmoCtry_cw + PFSCtry_cw + c19NormShouldCtry_cw + WBCtry_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv123)
performance::icc(ana_lv123)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv123)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

```{r}
ana_lv123_int <- lme4::lmer(c19ProSo03 ~ negEmo_cw*c19NormShould_cw + posEmo_cw*c19NormShould_cw + PFS_cw*c19NormShould_cw + WB_cw*c19NormShould_cw + 
                      negEmoPP_cw*c19NormShouldPP_cw + posEmoPP_cw*c19NormShouldPP_cw + PFSPP_cw*c19NormShouldPP_cw + WBPP_cw*c19NormShouldPP_cw + 
                      negEmoCtry_cw*c19NormShouldCtry_cw + posEmoCtry_cw*c19NormShouldCtry_cw + PFSCtry_cw*c19NormShouldCtry_cw + WBCtry_cw*c19NormShouldCtry_cw + 
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv123_int)
performance::icc(ana_lv123_int)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
saveRes <- residuals(ana_lv123_int)
plot(saveRes)
autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
autocorrelation; rm(saveRes, autocorrelation)
```

#### cross-level interactions (1,2)
```{r}
ana_lv123_intCrossAll <- lme4::lmer(c19ProSo03 ~ negEmo_cw*c19NormShould_cw + posEmo_cw*c19NormShould_cw + PFS_cw*c19NormShould_cw + WB_cw*c19NormShould_cw +
                             negEmoPP_cw*c19NormShouldPP_cw + posEmoPP_cw*c19NormShouldPP_cw + PFSPP_cw*c19NormShouldPP_cw + WBPP_cw*c19NormShouldPP_cw + 
                             negEmo_cw*c19NormShouldPP_cw + posEmo_cw*c19NormShouldPP_cw + PFS_cw*c19NormShouldPP_cw + WB_cw*c19NormShouldPP_cw + 
                             negEmoCtry_cw*c19NormShouldCtry_cw + posEmoCtry_cw*c19NormShouldCtry_cw + PFSCtry_cw*c19NormShouldCtry_cw + WBCtry_cw*c19NormShouldCtry_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

ana_lv123_intCrossOnly <- lme4::lmer(c19ProSo03 ~ negEmo_cw + posEmo_cw + PFS_cw + c19NormShould_cw + WB_cw +
                             negEmoPP_cw + posEmoPP_cw + PFSPP_cw +  c19NormShouldPP_cw + WBPP_cw +
                             negEmo_cw*c19NormShouldPP_cw + posEmo_cw*c19NormShouldPP_cw + PFS_cw*c19NormShouldPP_cw + WB_cw*c19NormShouldPP_cw +   
                             negEmoCtry_cw + posEmoCtry_cw + PFSCtry_cw + c19NormShouldCtry_cw + WBCtry_cw +
                    (1|coded_country) + # each country can have its own intercept
                    (1|coded_country:PPID), # each person can have its own intercept relative to the country
                  data = dtLong)

summary(ana_lv123_intCrossAll)
performance::icc(ana_lv123_intCrossOnly)
summary(ana_lv123_intCrossAll)
performance::icc(ana_lv123_intCrossOnly)

# variances
# var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1))
# var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0))
# var.ana.0
# var.ana.1

# more importantly calculate autocorelation for residuals
# saveRes <- residuals(ana_lv123_intCross)
# plot(saveRes)
# autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass)
# autocorrelation; rm(saveRes, autocorrelation)

```

#### understand interactions
```{r}
# positive emotions (we save path A for later); important for indirect effects as well
# tmp_posEmo <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "posEmo_cw", modx = "c19NormShould_cw", 
#                          johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# tmp_negEmo <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "negEmo_cw", modx = "c19NormShould_cw", 
#                          johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# tmp_PFS <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "PFS_cw", modx = "c19NormShould_cw", 
#                          johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# tmp_posEmoPP <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "posEmoPP_cw", modx = "c19NormShouldPP_cw", 
#                          johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# tmp_negEmoPP <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "negEmoPP_cw", modx = "c19NormShouldPP_cw", 
#                          johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_PFSPP <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "PFSPP_cw", modx = "c19NormShouldPP_cw", 
                         johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_PFSPP
tmp_WBPP <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "WBPP_cw", modx = "c19NormShouldPP_cw", 
                         johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_WBPP
# tmp_posEmoCross <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "posEmo_cw", modx = "c19NormShouldPP_cw", 
#                          johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# tmp_negEmoCross <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "negEmo_cw", modx = "c19NormShouldPP_cw", 
#                          johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# tmp_negEmoCross
# tmp_PFSCross <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "PFS_cw", modx = "c19NormShouldPP_cw", 
#                          johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
# tmp_posEmoCtry <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "posEmoCtry_cw", modx = "c19NormShouldCtry_cw", 
#                          johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_negEmoCtry <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "negEmoCtry_cw", modx = "c19NormShouldCtry_cw", 
                         johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
tmp_negEmoCtry
# tmp_PFSCtry <- interactions::sim_slopes(ana_lv123_intCrossAll, pred = "PFSCtry_cw", modx = "c19NormShouldCtry_cw", 
#                          johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE)
```

#### save for indirect effects (B path)
```{r}
tmp <- summary(ana_lv123_intCrossAll)

paths_proSo <- data.frame(
  WB_B = tmp$coefficients['WB_cw','Estimate'],
  WB_varB = tmp$coefficients['WB_cw','Std. Error'],
  WBPP_B = tmp$coefficients['WBPP_cw','Estimate'],
  WBPP_varB = tmp$coefficients['WBPP_cw','Std. Error'],
  WBCtry_B = tmp$coefficients['WBCtry_cw','Estimate'],
  WBCtry_varB = tmp$coefficients['WBCtry_cw','Std. Error']
)
rm(tmp)
```

#### save tables
```{r}
 stargazer::stargazer(ana_lv0, ana_lv1, ana_lv1_int, ana_lv12, ana_lv12_int, ana_lv123, ana_lv123_int, ana_lv123_intCrossAll, 
                      ana_lv123_intCrossOnly,
                summary=FALSE,
                type='html',
                rownames = TRUE,
                initial.zero=FALSE,
                ci = TRUE,
                digits=2,
                digits.extra = 2,
                order = c(1, 22, 27, 2, 23, 28, 3, 24, 29, 4, 25, 30, 5, 26, 31, 6, 10, 14, 18, 7, 11, 15, 19, 8, 12, 16, 20, 9, 13, 17, 21),
                title='ProSocial Group Mean Centering Analyses',
                column.labels = c("randomInt", "level1", "level1+int", "level1-2", "level1-2+int", "level1-3", "level1-3+int"),
                dep.var.labels = c("ProSocial"),
                out="output/tables/Longitudinal/Norms/proSo_CW.html")

stargazer::stargazer(ana_lv0, ana_lv1, ana_lv1_int, ana_lv12, ana_lv12_int, ana_lv123, ana_lv123_int, ana_lv123_intCrossAll, 
                      ana_lv123_intCrossOnly,
                summary=FALSE,
                type='html',
                rownames = TRUE,
                initial.zero=FALSE,
                ci = TRUE,
                digits=2,
                digits.extra = 2,
                # order = c(1, 14, 18, 2, 15, 19, 3, 16, 20),
                title='ProSocial Group Mean Centering Analyses',
                column.labels = c("randomInt", "level1", "level1+int", "level1-2", "level1-2+int", "level1-3", "level1-3+int"),
                dep.var.labels = c("ProSocial"),
                out="output/tables/Longitudinal/Norms/oldproSo_CW.html")

proSo_CW_out <- mlm_summary_out(ana_lv123_intCrossAll)

stargazer::stargazer(proSo_CW_out, 
                     out="output/tables/Longitudinal/Norms/proSo_CW_relOnly.html",
                     summary=FALSE,
                     type='html',
                     digits=3,
                     digits.extra = 3,
                     title='ProSocial Group Mean Centering Analyses')

#rm(list=ls(pattern="^ana"))
```

### calculate indirect effects
```{r}
dt_indirect <- data.frame(
# minus 1 SD c19NormShould
  # positive emotion
  # within participant level
  calc_indirect_effect(
    nameIn = "posEmo_minus1c19NormShouldSD",
    pathA = paths_WB$posEmo_minus1c19NormShouldSD_A,
    varA = paths_WB$posEmo_minus1c19NormShouldSD_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
   conf = 0.99),
  # between participant level
  calc_indirect_effect(
    nameIn = "posEmoPP_minus1c19NormShouldSD",
    pathA = paths_WB$posEmoPP_minus1c19NormShouldSD_A,
    varA = paths_WB$posEmoPP_minus1c19NormShouldSD_varA,
    pathB = paths_proSo$WBPP_B,
    varB = paths_proSo$WBPP_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  
  # cross-level (path B stays on the idividual level)
  calc_indirect_effect(
    nameIn = "posEmoCross_minus1c19NormShouldSD",
    pathA = paths_WB$posEmoCross_minus1c19NormShouldSD_A,
    varA = paths_WB$posEmoCross_minus1c19NormShouldSD_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  
  # negative emotion
  # within participant level
  calc_indirect_effect(
    nameIn = "negEmo_minus1c19NormShouldSD",
    pathA = paths_WB$negEmo_minus1c19NormShouldSD_A,
    varA = paths_WB$negEmo_minus1c19NormShouldSD_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
   conf = 0.99),
  # between participant level
  calc_indirect_effect(
    nameIn = "negEmoPP_minus1c19NormShouldSD",
    pathA = paths_WB$negEmoPP_minus1c19NormShouldSD_A,
    varA = paths_WB$negEmoPP_minus1c19NormShouldSD_varA,
    pathB = paths_proSo$WBPP_B,
    varB = paths_proSo$WBPP_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  # cross-level (path B stays on the idividual level)
  calc_indirect_effect(
    nameIn = "negEmoCross_minus1c19NormShouldSD",
    pathA = paths_WB$negEmoCross_minus1c19NormShouldSD_A,
    varA = paths_WB$negEmoCross_minus1c19NormShouldSD_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  
  # perceived financial strain
  # within participant level
  calc_indirect_effect(
    nameIn = "PFS_minus1c19NormShouldSD",
    pathA = paths_WB$PFS_minus1c19NormShouldSD_A,
    varA = paths_WB$PFS_minus1c19NormShouldSD_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
   conf = 0.99),
  # between participant level
  calc_indirect_effect(
    nameIn = "PFSPP_minus1c19NormShouldSD",
    pathA = paths_WB$PFSPP_minus1c19NormShouldSD_A,
    varA = paths_WB$PFSPP_minus1c19NormShouldSD_varA,
    pathB = paths_proSo$WBPP_B,
    varB = paths_proSo$WBPP_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  # cross-level (path B stays on the idividual level)
  calc_indirect_effect(
    nameIn = "PFSCross_minus1c19NormShouldSD",
    pathA = paths_WB$PFSCross_minus1c19NormShouldSD_A,
    varA = paths_WB$PFSCross_minus1c19NormShouldSD_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),

# plus 1 SD c19NormShould
  # positive emotion
  # within participant level
  calc_indirect_effect(
    nameIn = "posEmo_plus1c19NormShouldSD",
    pathA = paths_WB$posEmo_plus1c19NormShouldSD_A,
    varA = paths_WB$posEmo_plus1c19NormShouldSD_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
   conf = 0.99),
  # between participant level
  calc_indirect_effect(
    nameIn = "posEmoPP_plus1c19NormShouldSD",
    pathA = paths_WB$posEmoPP_plus1c19NormShouldSD_A,
    varA = paths_WB$posEmoPP_plus1c19NormShouldSD_varA,
    pathB = paths_proSo$WBPP_B,
    varB = paths_proSo$WBPP_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  
  # cross-level (path B stays on the idividual level)
  calc_indirect_effect(
    nameIn = "posEmoCross_plus1c19NormShouldSD",
    pathA = paths_WB$posEmoCross_plus1c19NormShouldSD_A,
    varA = paths_WB$posEmoCross_plus1c19NormShouldSD_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  
  # negative emotion
  # within participant level
  calc_indirect_effect(
    nameIn = "negEmo_plus1c19NormShouldSD",
    pathA = paths_WB$negEmo_plus1c19NormShouldSD_A,
    varA = paths_WB$negEmo_plus1c19NormShouldSD_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
   conf = 0.99),
  # between participant level
  calc_indirect_effect(
    nameIn = "negEmoPP_plus1c19NormShouldSD",
    pathA = paths_WB$negEmoPP_plus1c19NormShouldSD_A,
    varA = paths_WB$negEmoPP_plus1c19NormShouldSD_varA,
    pathB = paths_proSo$WBPP_B,
    varB = paths_proSo$WBPP_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  # cross-level (path B stays on the idividual level)
  calc_indirect_effect(
    nameIn = "negEmoCross_plus1c19NormShouldSD",
    pathA = paths_WB$negEmoCross_plus1c19NormShouldSD_A,
    varA = paths_WB$negEmoCross_plus1c19NormShouldSD_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  
  # perceived financial strain
  # within participant level
  calc_indirect_effect(
    nameIn = "PFS_plus1c19NormShouldSD",
    pathA = paths_WB$PFS_plus1c19NormShouldSD_A,
    varA = paths_WB$PFS_plus1c19NormShouldSD_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
   conf = 0.99),
  # between participant level
  calc_indirect_effect(
    nameIn = "PFSPP_plus1c19NormShouldSD",
    pathA = paths_WB$PFSPP_plus1c19NormShouldSD_A,
    varA = paths_WB$PFSPP_plus1c19NormShouldSD_varA,
    pathB = paths_proSo$WBPP_B,
    varB = paths_proSo$WBPP_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99),
  # cross-level (path B stays on the idividual level)
  calc_indirect_effect(
    nameIn = "PFSCross_plus1c19NormShouldSD",
    pathA = paths_WB$PFSCross_plus1c19NormShouldSD_A,
    varA = paths_WB$PFSCross_plus1c19NormShouldSD_varA,
    pathB = paths_proSo$WB_B,
    varB = paths_proSo$WB_varB,
    covAB = 0,
    rep = 5000, 
    conf = 0.99)
)

dt_indirect <- matrix(unlist(t(dt_indirect)), byrow = T, nrow = ncol(dt_indirect)/3, ncol = 3)

stargazer::stargazer(dt_indirect, 
                     out="output/tables/Longitudinal/Norms/indirect_effects.html",
                     summary=FALSE,
                     type='html',
                     digits=3,
                     digits.extra = 3,
                     title='Indirect effects')



```

# Illustration multilevel
```{r}



```



```{r}
# run all
```

<!-- ## Multilevel (Grand mean centering) -->
<!-- CMC quite useful when within-cluster and between-cluster slopes may differ and one is mainly interesting in the within-cluster slope (based on Raudenbush and Bryk). As we see (similar to  Hamaker & Grasman, 2014) grand-mean centering (see above) results in larger effects as within-cluster centering biases effects to be smaller (more conservative and still valid) -->
<!-- ### Well-Being -->
<!-- http://www.alexanderdemos.org/Mixed5.html#plot_final_results_(fixed_effects_only) -->

<!-- First question: Do we need multilevel modeling? Run intercept only model! If amount of variance on level 2/3 is significant multilevel modeling is handy (but taking into account nestedness almost always is). -->
<!-- ```{r} -->
<!-- lm_lv0 <- lm(WB ~ 1, # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->
<!-- ana_lv0 <- lme4::lmer(WB ~ 1 +  -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- anova(ana_lv0, lm_lv0) -->
<!-- summary(ana_lv0) -->
<!-- performance::icc(ana_lv0) -->

<!-- # calculate the ACF for lags between 1 and 50 (inclusive); probably not too important due to the large amount of missingness -->
<!-- tmp <- dtLong %>% # sort after participant (if we have autocorrelation every 25 measurement should repeat) -->
<!--   arrange(PPID) -->

<!-- autocorrelation <- acf(dtLong$WB, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(tmp, autocorrelation) -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv0) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- Second step: Add all level 1 predictors -->
<!-- ```{r} -->
<!-- ana_lv1 <- lme4::lmer(WB ~ negEmo_c + posEmo_c + PFS_c + disemp_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv1) -->
<!-- performance::icc(ana_lv1) -->

<!-- # variances -->
<!-- var_ana_lv1 <- as.data.frame(lme4::VarCorr(ana_lv1)) -->
<!-- var_ana_lv0 <- as.data.frame(lme4::VarCorr(ana_lv0)) -->
<!-- var_ana_lv0 -->
<!-- var_ana_lv1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv1) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation, var_ana_lv0, var_ana_lv1) -->
<!-- ``` -->

<!-- Third step: Add all level 1 predictors and their interactions -->
<!-- ```{r} -->
<!-- ana_lv1_int <- lme4::lmer(WB ~ negEmo_c*disemp_c + posEmo_c*disemp_c + PFS_c*disemp_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv1_int) -->
<!-- performance::icc(ana_lv1_int) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv1_int) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- #### level 2 predictors -->
<!-- If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016) -->
<!-- ```{r} -->
<!-- ana_lv12 <- lme4::lmer(WB ~ negEmo_c + posEmo_c + PFS_c + disemp_c +  -->
<!--                          negEmoPP_c + posEmoPP_c + PFSPP_c + disempPP_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv12) -->
<!-- performance::icc(ana_lv12) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv12) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- ana_lv12_int <- lme4::lmer(WB ~ negEmo_c*disemp_c + posEmo_c*disemp_c + PFS_c*disemp_c +  -->
<!--                              negEmoPP_c*disempPP_c + posEmoPP_c*disempPP_c + PFSPP_c*disempPP_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv12_int) -->
<!-- performance::icc(ana_lv12_int) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv12_int) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->

<!-- # interactiosn -->
<!-- # sjPlot::plot_model(ana_lv12_int, type = "int", mdrt.values = "meansd") -->
<!-- #  -->
<!-- # interactions::sim_slopes(ana_lv12_int, pred = "posEmo_c", modx = "disemp_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv12_int, pred = "negEmo_c", modx = "disemp_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv12_int, pred = "PFS_c", modx = "disemp_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv12_int, pred = "posEmoPP_c", modx = "disempPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv12_int, pred = "negEmoPP_c", modx = "disempPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv12_int, pred = "PFSPP_c", modx = "disempPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->

<!-- ``` -->
<!-- #### level 3 predictors -->
<!-- If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016) -->
<!-- ```{r} -->
<!-- ana_lv123 <- lme4::lmer(WB ~ negEmo_c + posEmo_c + PFS_c + disemp_c +  -->
<!--                           negEmoPP_c + posEmoPP_c + PFSPP_c + disempPP_c +  -->
<!--                       negEmoCtry_c + posEmoCtry_c + PFSCtry_c + disempCtry_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv123) -->
<!-- performance::icc(ana_lv123) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv123) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- ana_lv123_int <- lme4::lmer(WB ~ negEmo_c*disemp_c + posEmo_c*disemp_c + PFS_c*disemp_c +  -->
<!--                               negEmoPP_c*disempPP_c + posEmoPP_c*disempPP_c + PFSPP_c*disempPP_c + -->
<!--                       negEmoCtry_c*disempCtry_c + posEmoCtry_c*disempCtry_c + PFSCtry_c*disempCtry_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv123_int) -->
<!-- performance::icc(ana_lv123_int) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv123_int) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- #### cross-level interactions (1,2) -->
<!-- ```{r} -->
<!-- ana_lv123_intCrossAll <- lme4::lmer(WB ~ negEmo_c*disemp_c + posEmo_c*disemp_c + PFS_c*disemp_c +  -->
<!--                              negEmoPP_c*disempPP_c + posEmoPP_c*disempPP_c + PFSPP_c*disempPP_c +   -->
<!--                              negEmo_c*disempPP_c + posEmo_c*disempPP_c + PFS_c*disempPP_c +   -->
<!--                              negEmoCtry_c*disempCtry_c + posEmoCtry_c*disempCtry_c + PFSCtry_c*disempCtry_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- ana_lv123_intCrossOnly <- lme4::lmer(WB ~ negEmo_c + posEmo_c + PFS_c + disemp_c + -->
<!--                              negEmoPP_c + posEmoPP_c + PFSPP_c +  disempPP_c + -->
<!--                              negEmo_c*disempPP_c + posEmo_c*disempPP_c + PFS_c*disempPP_c +   -->
<!--                              negEmoCtry_c + posEmoCtry_c + PFSCtry_c + disempCtry_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv123_intCrossAll) -->
<!-- performance::icc(ana_lv123_intCrossOnly) -->
<!-- summary(ana_lv123_intCrossAll) -->
<!-- performance::icc(ana_lv123_intCrossOnly) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- # saveRes <- residuals(ana_lv123_intCross) -->
<!-- # plot(saveRes) -->
<!-- # autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- # autocorrelation; rm(saveRes, autocorrelation) -->

<!-- # interactiosn -->
<!-- # sjPlot::plot_model(ana_lv123_intCross, type = "int", mdrt.values = "meansd") -->
<!-- #  -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "posEmo_c", modx = "disemp_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "negEmo_c", modx = "disemp_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "PFS_c", modx = "disemp_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "posEmoPP_c", modx = "disempPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "negEmoPP_c", modx = "disempPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "PFSPP_c", modx = "disempPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- ``` -->

<!-- #### save tables -->
<!-- ```{r} -->
<!--  stargazer::stargazer(ana_lv0, ana_lv1, ana_lv1_int, ana_lv12, ana_lv12_int, ana_lv123, ana_lv123_int,  -->
<!--                       ana_lv123_intCrossAll, ana_lv123_intCrossOnly, -->
<!--                 summary=FALSE, -->
<!--                 type='html', -->
<!--                 rownames = TRUE, -->
<!--                 initial.zero=FALSE, -->
<!--                 ci = TRUE, -->
<!--                 digits=2, -->
<!--                 digits.extra = 2, -->
<!--                 order = c(1, 17, 21, 2, 18, 22, 3, 19, 23, 16, 20, 24, 4, 7, 10, 13, 5, 8, 11, 14, 6, 9, 12, 15), -->
<!--                 title='WellBeing Group Mean Centering Analyses', -->
<!--                 column.labels = c("randomInt", "level1", "level1+int", "level1-2", "level1-2+int", "level1-3", "level1-3+int", -->
<!--                                   "level 1-3+crossIntAll", "level 1-3+crossIntOnly"), -->
<!--                 dep.var.labels = c("Well-Being"), -->
<!--                 out="output/tables/WB_c.html") -->

<!-- # stargazer::stargazer(ana_lv0, ana_lv1, ana_lv1_int, ana_lv12, ana_lv12_int, ana_lv123, ana_lv123_int,  -->
<!-- #                       ana_lv123_intCrossAll, ana_lv123_intCrossOnly, -->
<!-- #                 summary=FALSE, -->
<!-- #                 type='html', -->
<!-- #                 rownames = TRUE, -->
<!-- #                 initial.zero=FALSE, -->
<!-- #                 ci = TRUE, -->
<!-- #                 digits=2, -->
<!-- #                 digits.extra = 2, -->
<!-- #                 # order = c(1, 14, 18, 2, 15, 19, 3, 16, 20), -->
<!-- #                 title='WellBeing Analyses', -->
<!-- #                 column.labels = c("randomInt", "level1", "level1+int", "level1-2", "level1-2+int", "level1-3", "level1-3+int",  -->
<!-- #                                   "level 1-3+crossIntAll", "level 1-3+crossIntOnly"), -->
<!-- #                 dep.var.labels = c("Well-Being"), -->
<!-- #                 out="output/tables/oldWB_c.html") -->

<!-- rm(list=ls(pattern="^ana")) -->
<!-- ``` -->

<!-- ### Pro-Sociality (no well-being) -->
<!-- http://www.alexanderdemos.org/Mixed5.html#plot_final_results_(fixed_effects_only) -->

<!-- We have `r nrow(dtLong)-sum(is.na(dtLong$affAnx))` total measurements. -->
<!-- First question: Do we need multilevel modeling? Run intercept only model! If amount of variance on level 2/3 is significant multilevel modeling is handy (but taking into account nestedness almost always is). -->
<!-- ```{r} -->
<!-- lm_0 <- lm(c19ProSo03 ~ 1, # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->
<!-- ana_lv0 <- lme4::lmer(c19ProSo03 ~ 1 +  -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- anova(ana_lv0, lm_0) -->
<!-- summary(ana_lv0) -->
<!-- performance::icc(ana_lv0) -->

<!-- # calculate the ACF for lags between 1 and 50 (inclusive); probably not too important due to the large amount of missingness -->
<!-- tmp <- dtLong %>% # sort after participant (if we have autocorrelation every 25 measurement should repeat) -->
<!--   arrange(PPID) -->

<!-- autocorrelation <- acf(dtLong$c19ProSo03, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(tmp, autocorrelation) -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv0) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- Second step: Add all level 1 predictors -->
<!-- ```{r} -->
<!-- ana_lv1 <- lme4::lmer(c19ProSo03 ~ negEmo_c + posEmo_c + PFS_c + disemp_c +  -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv1) -->
<!-- performance::icc(ana_lv1) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana_lv1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana_lv0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv1) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- Third step: Add all level 1 predictors and their interactions -->
<!-- ```{r} -->
<!-- ana_lv1_int <- lme4::lmer(c19ProSo03 ~ negEmo_c*disemp_c + posEmo_c*disemp_c + PFS_c*disemp_c +  -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv1_int) -->
<!-- performance::icc(ana_lv1_int) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana_lv1_int)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv1_int) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- #### level 2 predictors -->
<!-- If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016) -->
<!-- ```{r} -->
<!-- ana_lv12 <- lme4::lmer(c19ProSo03 ~ negEmo_c + posEmo_c + PFS_c + disemp_c +   -->
<!--                          negEmoPP_c + posEmoPP_c + PFSPP_c + disempPP_c +  -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv12) -->
<!-- performance::icc(ana_lv12) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv12) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- ana_lv12_int <- lme4::lmer(c19ProSo03 ~ negEmo_c*disemp_c + posEmo_c*disemp_c + PFS_c*disemp_c +  -->
<!--                              negEmoPP_c*disempPP_c + posEmoPP_c*disempPP_c + PFSPP_c*disempPP_c +   -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv12_int) -->
<!-- performance::icc(ana_lv12_int) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv12_int) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->

<!-- # interactiosn -->
<!-- # sjPlot::plot_model(ana_lv12_int, type = "int", mdrt.values = "meansd") -->
<!-- #  -->
<!-- # interactions::sim_slopes(ana_lv12_int, pred = "posEmo_c", modx = "disemp_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv12_int, pred = "negEmo_c", modx = "disemp_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv12_int, pred = "PFS_c", modx = "disemp_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv12_int, pred = "posEmoPP_c", modx = "disempPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv12_int, pred = "negEmoPP_c", modx = "disempPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv12_int, pred = "PFSPP_c", modx = "disempPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- ``` -->

<!-- #### level 3 predictors -->
<!-- If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016) -->
<!-- ```{r} -->
<!-- ana_lv123 <- lme4::lmer(c19ProSo03 ~ negEmo_c + posEmo_c + PFS_c + disemp_c +   -->
<!--                       negEmoPP_c + posEmoPP_c + PFSPP_c + disempPP_c +  -->
<!--                       negEmoCtry_c + posEmoCtry_c + PFSCtry_c + disempCtry_c +  -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv123) -->
<!-- performance::icc(ana_lv123) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv123) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- ana_lv123_int <- lme4::lmer(c19ProSo03 ~ negEmo_c*disemp_c + posEmo_c*disemp_c + PFS_c*disemp_c +   -->
<!--                       negEmoPP_c*disempPP_c + posEmoPP_c*disempPP_c + PFSPP_c*disempPP_c +  -->
<!--                       negEmoCtry_c*disempCtry_c + posEmoCtry_c*disempCtry_c + PFSCtry_c*disempCtry_c +   -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv123_int) -->
<!-- performance::icc(ana_lv123_int) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv123_int) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- #### cross-level interactions (1,2) -->
<!-- ```{r} -->
<!-- ana_lv123_intCrossAll <- lme4::lmer(c19ProSo03 ~ negEmo_c*disemp_c + posEmo_c*disemp_c + PFS_c*disemp_c +  -->
<!--                              negEmoPP_c*disempPP_c + posEmoPP_c*disempPP_c + PFSPP_c*disempPP_c +   -->
<!--                              negEmo_c*disempPP_c + posEmo_c*disempPP_c + PFS_c*disempPP_c +   -->
<!--                              negEmoCtry_c*disempCtry_c + posEmoCtry_c*disempCtry_c + PFSCtry_c*disempCtry_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- ana_lv123_intCrossOnly <- lme4::lmer(c19ProSo03 ~ negEmo_c + posEmo_c + PFS_c + disemp_c + -->
<!--                              negEmoPP_c + posEmoPP_c + PFSPP_c +  disempPP_c + -->
<!--                              negEmo_c*disempPP_c + posEmo_c*disempPP_c + PFS_c*disempPP_c +   -->
<!--                              negEmoCtry_c + posEmoCtry_c + PFSCtry_c + disempCtry_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv123_intCrossAll) -->
<!-- performance::icc(ana_lv123_intCrossOnly) -->
<!-- summary(ana_lv123_intCrossAll) -->
<!-- performance::icc(ana_lv123_intCrossOnly) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- # saveRes <- residuals(ana_lv123_intCross) -->
<!-- # plot(saveRes) -->
<!-- # autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- # autocorrelation; rm(saveRes, autocorrelation) -->

<!-- # interactiosn -->
<!-- # sjPlot::plot_model(ana_lv123_intCross, type = "int", mdrt.values = "meansd") -->
<!-- #  -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "posEmo_c", modx = "disemp_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "negEmo_c", modx = "disemp_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "PFS_c", modx = "disemp_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "posEmoPP_c", modx = "disempPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "negEmoPP_c", modx = "disempPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "PFSPP_c", modx = "disempPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- ``` -->

<!-- #### save tables -->
<!-- ```{r} -->
<!--  stargazer::stargazer(ana_lv0, ana_lv1, ana_lv1_int, ana_lv12, ana_lv12_int, ana_lv123, ana_lv123_int,  -->
<!--                       ana_lv123_intCrossAll, ana_lv123_intCrossOnly, -->
<!--                 summary=FALSE, -->
<!--                 type='html', -->
<!--                 rownames = TRUE, -->
<!--                 initial.zero=FALSE, -->
<!--                 ci = TRUE, -->
<!--                 digits=2, -->
<!--                 digits.extra = 2, -->
<!--                 order = c(1, 17, 21, 2, 18, 22, 3, 19, 23, 16, 20, 24, 4, 7, 10, 13, 5, 8, 11, 14, 6, 9, 12, 15), -->
<!--                 title='ProSocial Group Mean Centering Analyses', -->
<!--                 column.labels = c("randomInt", "level1", "level1+int", "level1-2", "level1-2+int", "level1-3", "level1-3+int"), -->
<!--                 dep.var.labels = c("ProSocial"), -->
<!--                 out="output/tables/proSo_noWellBeing_c.html") -->

<!-- stargazer::stargazer(ana_lv0, ana_lv1, ana_lv1_int, ana_lv12, ana_lv12_int, ana_lv123, ana_lv123_int,  -->
<!--                       ana_lv123_intCrossAll, ana_lv123_intCrossOnly, -->
<!--                 summary=FALSE, -->
<!--                 type='html', -->
<!--                 rownames = TRUE, -->
<!--                 initial.zero=FALSE, -->
<!--                 ci = TRUE, -->
<!--                 digits=2, -->
<!--                 digits.extra = 2, -->
<!--                 # order = c(1, 14, 18, 2, 15, 19, 3, 16, 20), -->
<!--                 title='ProSocial Group Mean Centering Analyses', -->
<!--                 column.labels = c("randomInt", "level1", "level1+int", "level1-2", "level1-2+int", "level1-3", "level1-3+int"), -->
<!--                 dep.var.labels = c("ProSocial"), -->
<!--                 out="output/tables/oldProSocial_noWellBeing_c.html") -->

<!-- rm(list=ls(pattern="^ana")) -->
<!-- ``` -->

<!-- ### Pro-Sociality (controlling for Well-Being) -->
<!-- http://www.alexanderdemos.org/Mixed5.html#plot_final_results_(fixed_effects_only) -->

<!-- We have `r nrow(dtLong)-sum(is.na(dtLong$affAnx))` total measurements. -->
<!-- First question: Do we need multilevel modeling? Run intercept only model! If amount of variance on level 2/3 is significant multilevel modeling is handy (but taking into account nestedness almost always is). -->
<!-- ```{r} -->
<!-- lm_0 <- lm(c19ProSo03 ~ 1, # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->
<!-- ana_lv0 <- lme4::lmer(c19ProSo03 ~ 1 +  -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- anova(ana_lv0, lm_0) -->
<!-- summary(ana_lv0) -->
<!-- performance::icc(ana_lv0) -->

<!-- # calculate the ACF for lags between 1 and 50 (inclusive); probably not too important due to the large amount of missingness -->
<!-- tmp <- dtLong %>% # sort after participant (if we have autocorrelation every 25 measurement should repeat) -->
<!--   arrange(PPID) -->

<!-- autocorrelation <- acf(dtLong$c19ProSo03, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(tmp, autocorrelation) -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv0) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- Second step: Add all level 1 predictors -->
<!-- ```{r} -->
<!-- ana_lv1 <- lme4::lmer(c19ProSo03 ~ negEmo_c + posEmo_c + PFS_c + disemp_c + WB_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv1) -->
<!-- performance::icc(ana_lv1) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana_lv1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana_lv0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv1) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- Third step: Add all level 1 predictors and their interactions -->
<!-- ```{r} -->
<!-- ana_lv1_int <- lme4::lmer(c19ProSo03 ~ negEmo_c*disemp_c + posEmo_c*disemp_c + PFS_c*disemp_c + WB_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv1_int) -->
<!-- performance::icc(ana_lv1_int) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana_lv1_int)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv1_int) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- #### level 2 predictors -->
<!-- If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016) -->
<!-- ```{r} -->
<!-- ana_lv12 <- lme4::lmer(c19ProSo03 ~ negEmo_c + posEmo_c + PFS_c + disemp_c + WB_c +  -->
<!--                          negEmoPP_c + posEmoPP_c + PFSPP_c + disempPP_c + WBPP_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv12) -->
<!-- performance::icc(ana_lv12) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv12) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- ana_lv12_int <- lme4::lmer(c19ProSo03 ~ negEmo_c*disemp_c + posEmo_c*disemp_c + PFS_c*disemp_c + WB_c*disemp_c +  -->
<!--                              negEmoPP_c*disempPP_c + posEmoPP_c*disempPP_c + PFSPP_c*disempPP_c + WBPP_c*disempPP_c +  -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv12_int) -->
<!-- performance::icc(ana_lv12_int) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv12_int) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- #### level 3 predictors -->
<!-- If at all we are underestimating effects on level 2 due to potential small cluster size (Schunck, 2016) -->
<!-- ```{r} -->
<!-- ana_lv123 <- lme4::lmer(c19ProSo03 ~ negEmo_c + posEmo_c + PFS_c + disemp_c + WB_c +  -->
<!--                       negEmoPP_c + posEmoPP_c + PFSPP_c + disempPP_c + WBPP_c + -->
<!--                       negEmoCtry_c + posEmoCtry_c + PFSCtry_c + disempCtry_c + WBCtry_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv123) -->
<!-- performance::icc(ana_lv123) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv123) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- ```{r} -->
<!-- ana_lv123_int <- lme4::lmer(c19ProSo03 ~ negEmo_c*disemp_c + posEmo_c*disemp_c + PFS_c*disemp_c + WB_c*disemp_c +  -->
<!--                       negEmoPP_c*disempPP_c + posEmoPP_c*disempPP_c + PFSPP_c*disempPP_c + WBPP_c*disempPP_c +  -->
<!--                       negEmoCtry_c*disempCtry_c + posEmoCtry_c*disempCtry_c + PFSCtry_c*disempCtry_c + WBCtry_c*disempCtry_c +  -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv123_int) -->
<!-- performance::icc(ana_lv123_int) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- saveRes <- residuals(ana_lv123_int) -->
<!-- plot(saveRes) -->
<!-- autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- autocorrelation; rm(saveRes, autocorrelation) -->
<!-- ``` -->

<!-- #### cross-level interactions (1,2) -->
<!-- ```{r} -->
<!-- ana_lv123_intCrossAll <- lme4::lmer(c19ProSo03 ~ negEmo_c*disemp_c + posEmo_c*disemp_c + PFS_c*disemp_c + WB_c*disemp_c + -->
<!--                              negEmoPP_c*disempPP_c + posEmoPP_c*disempPP_c + PFSPP_c*disempPP_c + WBPP_c*disempPP_c +  -->
<!--                              negEmo_c*disempPP_c + posEmo_c*disempPP_c + PFS_c*disempPP_c + WB_c*disempPP_c +  -->
<!--                              negEmoCtry_c*disempCtry_c + posEmoCtry_c*disempCtry_c + PFSCtry_c*disempCtry_c + WBCtry_c*disempCtry_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- ana_lv123_intCrossOnly <- lme4::lmer(c19ProSo03 ~ negEmo_c + posEmo_c + PFS_c + disemp_c + WB_c + -->
<!--                              negEmoPP_c + posEmoPP_c + PFSPP_c +  disempPP_c + WBPP_c + -->
<!--                              negEmo_c*disempPP_c + posEmo_c*disempPP_c + PFS_c*disempPP_c + WB_c*disempPP_c +    -->
<!--                              negEmoCtry_c + posEmoCtry_c + PFSCtry_c + disempCtry_c + WBCtry_c + -->
<!--                     (1|coded_country) + # each country can have its own intercept -->
<!--                     (1|coded_country:PPID), # each person can have its own intercept relative to the country -->
<!--                   data = dtLong) -->

<!-- summary(ana_lv123_intCrossAll) -->
<!-- performance::icc(ana_lv123_intCrossOnly) -->
<!-- summary(ana_lv123_intCrossAll) -->
<!-- performance::icc(ana_lv123_intCrossOnly) -->

<!-- # variances -->
<!-- # var.ana.1 <- as.data.frame(lme4::VarCorr(ana.1)) -->
<!-- # var.ana.0 <- as.data.frame(lme4::VarCorr(ana.0)) -->
<!-- # var.ana.0 -->
<!-- # var.ana.1 -->

<!-- # more importantly calculate autocorelation for residuals -->
<!-- # saveRes <- residuals(ana_lv123_intCross) -->
<!-- # plot(saveRes) -->
<!-- # autocorrelation <- acf(saveRes, lag.max=50, plot=T, na.action = na.pass) -->
<!-- # autocorrelation; rm(saveRes, autocorrelation) -->

<!-- # interactiosn -->
<!-- # sjPlot::plot_model(ana_lv123_intCross, type = "int", mdrt.values = "meansd") -->
<!-- #  -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "posEmo_c", modx = "disemp_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "negEmo_c", modx = "disemp_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "PFS_c", modx = "disemp_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "posEmoPP_c", modx = "disempPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "negEmoPP_c", modx = "disempPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- # interactions::sim_slopes(ana_lv123_intCross, pred = "PFSPP_c", modx = "disempPP_c", johnson_neyman = TRUE, jnplot = TRUE, confint = TRUE) -->
<!-- ``` -->

<!-- #### save tables -->
<!-- ```{r} -->
<!--  stargazer::stargazer(ana_lv0, ana_lv1, ana_lv1_int, ana_lv12, ana_lv12_int, ana_lv123, ana_lv123_int, ana_lv123_intCrossAll,  -->
<!--                       ana_lv123_intCrossOnly, -->
<!--                 summary=FALSE, -->
<!--                 type='html', -->
<!--                 rownames = TRUE, -->
<!--                 initial.zero=FALSE, -->
<!--                 ci = TRUE, -->
<!--                 digits=2, -->
<!--                 digits.extra = 2, -->
<!--                 order = c(1, 22, 27, 2, 23, 28, 3, 24, 29, 4, 25, 30, 5, 26, 31, 6, 10, 14, 18, 7, 11, 15, 19, 8, 12, 16, 20, 9, 13, 17, 21), -->
<!--                 title='ProSocial Group Mean Centering Analyses', -->
<!--                 column.labels = c("randomInt", "level1", "level1+int", "level1-2", "level1-2+int", "level1-3", "level1-3+int"), -->
<!--                 dep.var.labels = c("ProSocial"), -->
<!--                 out="output/tables/proSo_c.html") -->

<!-- stargazer::stargazer(ana_lv0, ana_lv1, ana_lv1_int, ana_lv12, ana_lv12_int, ana_lv123, ana_lv123_int, ana_lv123_intCrossAll,  -->
<!--                       ana_lv123_intCrossOnly, -->
<!--                 summary=FALSE, -->
<!--                 type='html', -->
<!--                 rownames = TRUE, -->
<!--                 initial.zero=FALSE, -->
<!--                 ci = TRUE, -->
<!--                 digits=2, -->
<!--                 digits.extra = 2, -->
<!--                 # order = c(1, 14, 18, 2, 15, 19, 3, 16, 20), -->
<!--                 title='ProSocial Group Mean Centering Analyses', -->
<!--                 column.labels = c("randomInt", "level1", "level1+int", "level1-2", "level1-2+int", "level1-3", "level1-3+int"), -->
<!--                 dep.var.labels = c("ProSocial"), -->
<!--                 out="output/tables/oldproSo_c.html") -->

<!-- #rm(list=ls(pattern="^ana")) -->
<!-- ``` -->




<!-- # Additional analyses -->
<!-- 1. add random slopes; especially if slopes are fixed (and random slopes do not add anything) can be quite interesting) -->
<!-- 2. understand between-participant and country level effects (maybe by calculating means per participant) -->
<!-- 3. We could also model time? (time as IV) -->


<!-- # Multilevel Mediation? -->
<!-- ```{r} -->
<!-- mlmaData <- mlma::data.org(x = cbind(dtLong$negEmo_cw, dtLong$posEmo_cw, dtLong$PFS_cw), -->
<!--                            m = dtLong$WB_cw, -->
<!--                            y = dtLong$c19ProSo03, -->
<!--                            level = cbind(dtLong$coded_country, dtLong$PPID)) -->
<!-- ``` -->


<!-- <!-- # Analysis Baseline --> -->
<!-- <!-- ## MPlus Preparation --> -->
<!-- <!-- ```{r} --> -->
<!-- <!--  dtOut <- dtCtry %>% --> -->
<!--   select(contains("c19ProSo")) -->

<!--   prepareMplusData(dtOut[, 1:ncol(dtOut)],  -->
<!--                    "test.dat") -->


<!-- ``` -->



<!-- ## Confirmatory Factor Analysis -->
<!-- ```{r explrFactor12} -->
<!--   model <- 'level:1 -->
<!--             # Latent -->
<!--             posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel  -->
<!--             negEmo =~ affAnx + affDepr + affNerv + affExh -->
<!--             PFS =~ PFS01 + PFS02 + PFS03 -->
<!--             disemp =~ fail01 + fail02 + fail03 -->
<!--             wellBe =~ happy + lifeSat + MLQ -->
<!--             proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03 -->
<!--             level:2 -->
<!--             posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel -->
<!--             negEmo =~ affAnx + affDepr + affNerv + affExh -->
<!--             disemp =~ fail01 + fail02 + fail03 -->
<!--             PFS =~ PFS01 + PFS02 + PFS03 -->
<!--             wellBe =~ happy + lifeSat + MLQ -->
<!--             proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03' -->
<!-- #fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em") -->
<!-- fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em", verbose = T, em.iter.max = 20000, -->
<!--            em.fx.tol = 1e-08, em.dx.tol = 1e-04) -->
<!-- summary(fit, fit.measures=TRUE) -->
<!-- lavaanPlot::lavaanPlot(model = fit, coefs = T, covs = T) -->
<!-- ``` -->

<!-- <!-- ### MultiGroup Confirmatory Factor Analysis --> -->
<!-- <!-- ```{r explrFactor} --> -->
<!-- <!-- # by country all --> -->
<!-- <!--   fitGroup <- cfa(model, data = dtCtry, group = "coded_country") --> -->
<!-- <!--   summary(fitGroup, fit.measures=TRUE) --> -->

<!-- <!-- # by country constrained --> -->
<!-- <!--   #fitGroupConstr <- sem(model, dtCtry, group = "coded_country", group.equal = c("intercepts", "regressions")) --> -->

<!-- <!-- # compare unconstrained and constrained --> -->
<!-- <!--   #anova(fitGroup, fitGroupConstr) --> -->
<!-- <!-- ``` --> -->

<!-- ## MultiLevel Approach -->
<!-- ### posEmo - Well-Being with Fixed Slope -->
<!-- ```{r} -->
<!-- tmp <- ggplot(dtCtry, aes(x = posEmo.m, y = WB.m)) + -->
<!--   geom_point()+ -->
<!--   geom_smooth(method = 'lm')+ -->
<!--   theme_minimal() -->

<!-- ggExtra::ggMarginal( -->
<!--   tmp, type = 'histogram', margins = 'both', size = 4, col = '#0F0101', fill = '#37AAE8' -->
<!-- ) -->

<!-- # fit model with fixed slope -->
<!--   mod1Fix <- lme4::lmer(WB.m ~ posEmo.c + (1|coded_country), data = dtCtry) -->
<!--   summary(mod1Fix) -->
<!-- ``` -->

<!-- ### posEmo - Well-Being with Random Slope -->
<!-- ```{r} -->
<!-- tmp <- ggplot(dtCtry, aes(x = posEmo.m, y = WB.m, color = coded_country)) + -->
<!--   geom_point()+ -->
<!--   geom_smooth(method = 'lm')+ -->
<!--   theme_minimal() -->
<!-- plotly::ggplotly(tmp) -->

<!-- # fit model with random slope -->
<!--   mod1Rand <- lme4::lmer(WB.m ~ posEmo.c + (1 + posEmo.c|coded_country), data = dtCtry) -->
<!--   anova(mod1Fix, mod1Rand) # test diff -->
<!--   summary(mod1Rand) -->
<!--   sjPlot::plot_model(mod1Rand, type = c("re"), show.values = T, value.offset = .5) -->

<!-- ``` -->

<!-- ### Pro-Social - Well-Being with Fixed Slope -->
<!-- ```{r} -->
<!-- tmp <- ggplot(dtCtry, aes(x = c19ProSo.m, y = WB.m)) + -->
<!--   geom_point()+ -->
<!--   geom_smooth(method = 'lm')+ -->
<!--   theme_minimal() -->

<!-- ggExtra::ggMarginal( -->
<!--   tmp, type = 'histogram', margins = 'both', size = 4, col = '#0F0101', fill = '#37AAE8' -->
<!-- ) -->

<!-- # fit model with fixed slope -->
<!--   mod2Fix <- lme4::lmer(WB.m ~ c19ProSo.c + (1|coded_country), data = dtCtry) -->
<!--   summary(mod2Fix) -->
<!-- ``` -->

<!-- ### ProSo - Well-Being with Random Slope -->
<!-- ```{r} -->
<!-- tmp <- ggplot(dtCtry, aes(x = c19ProSo.m, y = WB.m, color = coded_country)) + -->
<!--   geom_point()+ -->
<!--   geom_smooth(method = 'lm')+ -->
<!--   theme_minimal() -->
<!-- plotly::ggplotly(tmp) -->

<!-- # fit model with random slope -->
<!--   mod2Rand <- lme4::lmer(WB.m ~ c19ProSo.c + (1 + c19ProSo.c|coded_country), data = dtCtry) -->
<!--   anova(mod2Fix, mod2Rand) # test diff -->
<!--   summary(mod2Rand) -->
<!--   sjPlot::plot_model(mod2Rand, type =  c("re"), show.values = T, value.offset = .5) -->
<!-- ``` -->

<!-- ### posEmo -ProSo - Well-Being with Fixed Slope -->
<!-- ```{r} -->
<!-- # tmp <- ggplot(dtCtry, aes(x = c19ProSo.m, y = WB.m, color = coded_country)) + -->
<!-- #   geom_point()+ -->
<!-- #   geom_smooth(method = 'lm')+ -->
<!-- #   theme_minimal() -->
<!-- # plotly::ggplotly(tmp) -->

<!-- # fit model with random slope -->
<!--   mod3Fix <- lme4::lmer(WB.m ~ c19ProSo.c + posEmo.c + (1|coded_country), data = dtCtry) -->
<!--   summary(mod3Fix) -->
<!--   sjPlot::plot_model(mod3Fix, type =  c("re"), show.values = T, value.offset = .5) -->
<!-- ``` -->

<!-- ### posEmo -ProSo - Well-Being with Random Slope -->
<!-- ```{r} -->
<!-- # tmp <- ggplot(dtCtry, aes(x = c19ProSo.m, y = WB.m, color = coded_country)) + -->
<!-- #   geom_point()+ -->
<!-- #   geom_smooth(method = 'lm')+ -->
<!-- #   theme_minimal() -->
<!-- # plotly::ggplotly(tmp) -->

<!-- # fit model with random slope -->
<!--   mod3Rand <- lme4::lmer(WB.m ~ c19ProSo.c + posEmo.c + (1+ c19ProSo.c + posEmo.c |coded_country), data = dtCtry, REML = FALSE,  control = lme4::lmerControl(optimizer ="Nelder_Mead")) -->
<!--   summary(mod3Rand) -->
<!--   sjPlot::plot_model(mod3Rand, type =  c("re"), show.values = T, value.offset = .5) -->
<!-- ``` -->

<!-- ### DV: Well-Being full model -->
<!-- ```{r} -->
<!-- # fit model with random slope -->
<!--   mod5Med <- lme4::lmer(WB.z ~ disemp.z*posEmo.z + disemp.z*negEmo.z + disemp.z*PFS.z + (1 |coded_country), data = dtCtry) -->
<!--   mod5DV <- lme4::lmer(c19ProSo.m ~ WB.z + disemp.z*posEmo.z + disemp.z*negEmo.z + disemp.z*PFS.z + (1 |coded_country), data = dtCtry) -->
<!--   summary(mod5Med) -->
<!--   summary(mod5DV) -->
<!-- # mediation   -->
<!--   anaMed <- mediation::mediate(mod5Med, mod5DV, treat='negEmo.z', mediator='WB.z', sims = 100) -->
<!--   summary(anaMed) -->
<!-- # test for moderated mediation -->
<!--   mediation::test.modmed(anaMed, list(disemp.z = -1), covariates.2 = list(disemp.z = 1), sims = 100) -->

<!-- # test for values at different levels of moderator  -->



<!--   lattice::dotplot(ranef(mod5Rand, postVar=TRUE)) -->



<!-- ``` -->

<!-- ### Table: Multilevel Approach -->
<!-- ```{r} -->
<!-- sjPlot::tab_model(mod1Fix, mod1Rand, mod2Fix, mod2Rand, mod3Fix, mod3Rand) -->
<!-- ``` -->


<!-- ## Multilevel Path Modeling -->
<!-- ### CFA: Check latent constructs -->
<!-- ```{r} -->
<!--   model <- 'level:1 -->
<!--             # Latent -->
<!--             posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel  -->
<!--             negEmo =~ affAnx + affDepr + affNerv + affExh -->
<!--             PFS =~ PFS01 + PFS02 + PFS03 -->
<!--             disemp =~ fail01 + fail02 + fail03 -->
<!--             wellBe =~ happy + lifeSat + MLQ -->
<!--             proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03 -->
<!--             level:2 -->
<!--             posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel -->
<!--             negEmo =~ affAnx + affDepr + affNerv + affExh -->
<!--             disemp =~ fail01 + fail02 + fail03 -->
<!--             PFS =~ PFS01 + PFS02 + PFS03 -->
<!--             wellBe =~ happy + lifeSat + MLQ -->
<!--             proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03' -->
<!-- #fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em") -->
<!-- fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em", verbose = T, em.iter.max = 20000, -->
<!--            em.fx.tol = 1e-08, em.dx.tol = 1e-04) -->
<!-- summary(fit, fit.measures=TRUE) -->
<!-- lavaanPlot::lavaanPlot(model = fit, coefs = T, covs = T) -->

<!-- ``` -->

<!-- ### Well-Being as DV -->
<!-- We run a model in which the level 2 structure mirrors level 1. This means that on level 2 we model the intercepts (means) and one level 1 the values. -->
<!-- ```{r} -->
<!-- # Explanation for below (from: https://www.youtube.com/watch?v=GZMXEq7GPvY): -->
<!-- # By adding the same model again on level 2, we are estimating the latent means now -->
<!--   model <- 'level:1 -->
<!--             # a path -->
<!--             WB.m ~ a1*posEmo.c + a2*negEmo.c + a3*PFS.c + a4*disemp.c + a5*intPosEmoXDisemp + a6*intNegEmoXDisemp + a7*intPFSXDisemp -->
<!--             level:2 -->
<!--             # d path -->
<!--             WB.m ~ d1*posEmo.c + d2*negEmo.c + d3*PFS.c + d4*disemp.c + d5*intPosEmoXDisemp + d6*intNegEmoXDisemp + d7*intPFSXDisemp' -->
<!-- fit <- sem(model, data = dtCtry, cluster = "coded_country") -->
<!-- # fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em", verbose = T, em.iter.max = 20000, -->
<!-- #            em.fx.tol = 1e-08, em.dx.tol = 1e-04) -->
<!-- summary(fit, fit.measures=TRUE) -->
<!-- lavInspect(fit, "icc") -->
<!-- ``` -->

<!-- ### Pro-Sociality as DV -->
<!-- We run a model in which the level 2 structure mirrors level 1. This means that on level 2 we model the intercepts (means) and one level 1 the values. -->
<!-- ```{r} -->
<!-- # Explanation for below (from: https://www.youtube.com/watch?v=GZMXEq7GPvY): -->
<!-- # By adding the same model again on level 2, we are estimating the latent means now -->
<!--   model <- 'level:1 -->
<!--             # c path -->
<!--             c19ProSo.m ~ c1*posEmo.c + c2*negEmo.c + c3*PFS.c + c4*disemp.c + c5*intPosEmoXDisemp + c6*intNegEmoXDisemp + c7*intPFSXDisemp -->
<!--             # a path -->
<!--             WB.m ~ a1*posEmo.c + a2*negEmo.c + a3*PFS.c + a4*disemp.c + a5*intPosEmoXDisemp + a6*intNegEmoXDisemp + a7*intPFSXDisemp -->
<!--             # b path -->
<!--             c19ProSo.m ~ b1*WB.m -->
<!--             level:2 -->
<!--             # f path -->
<!--             c19ProSo.m ~ f1*posEmo.c + f2*negEmo.c + f3*PFS.c + f4*disemp.c + f5*intPosEmoXDisemp + f6*intNegEmoXDisemp + f7*intPFSXDisemp -->
<!--             # d path -->
<!--             WB.m ~ d1*posEmo.c + d2*negEmo.c + d3*PFS.c + d4*disemp.c + d5*intPosEmoXDisemp + d6*intNegEmoXDisemp + d7*intPFSXDisemp -->
<!--             # e path -->
<!--             c19ProSo.m ~ e1*WB.m' -->
<!-- fit <- sem(model, data = dtCtry, cluster = "coded_country") -->
<!-- # fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em", verbose = T, em.iter.max = 20000, -->
<!-- #            em.fx.tol = 1e-08, em.dx.tol = 1e-04) -->
<!-- summary(fit, fit.measures=TRUE) -->
<!-- lavInspect(fit, "icc") -->
<!-- ``` -->

<!-- # OLD CODE: THIS IS REALLY COOL BUT DOES NOT WORK VERY WELL -->
<!-- ## Multilevel SEM -->
<!-- ### Mean Center all relevant vars -->
<!-- ```{r} -->
<!-- # mean center the individual scales (this works but want to be sure) -->
<!--   # dtCtry <- dtCtry %>% -->
<!--   #   dplyr::mutate_at(vars(matches( -->
<!--   #     paste(c("aff", "PFS", "fail", "happy", "lifeSat", "MLQ", "c19ProSo"), collapse = "|"), -contains("DO"))), #vars changed -->
<!--   #     scale, center = T, scale = F) #function for change -->


<!-- # mean center "save" way -->
<!-- dtCtry <- dtCtry %>% -->
<!--     mutate(affCalm = scale(affCalm, center = T, scale = F), -->
<!--            affContent = scale(affContent, center = T, scale = F), -->
<!--            affEnerg = scale(affEnerg, center = T, scale = F), -->
<!--            affInsp = scale(affInsp, center = T, scale = F), -->
<!--            affRel = scale(affRel, center = T, scale = F), -->
<!--            affAnx = scale(affAnx, center = T, scale = F), -->
<!--            affDepr = scale(affDepr, center = T, scale = F), -->
<!--            affNerv = scale(affNerv, center = T, scale = F), -->
<!--            affExh = scale(affExh, center = T, scale = F), -->
<!--            PFS01 = scale(PFS01, center = T, scale = F), -->
<!--            PFS02 = scale(PFS02, center = T, scale = F), -->
<!--            PFS03 = scale(PFS03, center = T, scale = F), -->
<!--            fail01 = scale(fail01, center = T, scale = F), -->
<!--            fail02 = scale(fail02, center = T, scale = F), -->
<!--            fail03 = scale(fail03, center = T, scale = F), -->
<!--            happy = scale(happy, center = T, scale = F), -->
<!--            lifeSat = scale(lifeSat, center = T, scale = F), -->
<!--            MLQ = scale(MLQ, center = T, scale = F), -->
<!--            c19ProSo01 = scale(c19ProSo01, center = T, scale = F), -->
<!--            c19ProSo02 = scale(c19ProSo02, center = T, scale = F), -->
<!--            c19ProSo03 = scale(c19ProSo03, center = T, scale = F), -->
<!--            c19ProSo04 = scale(c19ProSo04, center = T, scale = F), -->
<!--            ) -->


<!-- # calculate interactions for the latent constructs -->
<!--   dtCtry <- dtCtry %>% -->
<!--     mutate(fail01XposEmo01 = scale(fail01*affCalm, center = T, scale = F), -->
<!--            fail01XposEmo02 = scale(fail01*affContent, center = T, scale = F), -->
<!--            fail01XposEmo03 = scale(fail01*affEnerg, center = T, scale = F), -->
<!--            fail01XposEmo04 = scale(fail01*affInsp, center = T, scale = F), -->
<!--            fail01XposEmo05 = scale(fail01*affRel, center = T, scale = F), -->
<!--            fail02XposEmo01 = scale(fail02*affCalm, center = T, scale = F), -->
<!--            fail02XposEmo02 = scale(fail02*affContent, center = T, scale = F), -->
<!--            fail02XposEmo03 = scale(fail02*affEnerg, center = T, scale = F), -->
<!--            fail02XposEmo04 = scale(fail02*affInsp, center = T, scale = F), -->
<!--            fail02XposEmo05 = scale(fail02*affRel, center = T, scale = F), -->
<!--            fail03XposEmo01 = scale(fail03*affCalm, center = T, scale = F), -->
<!--            fail03XposEmo02 = scale(fail03*affContent, center = T, scale = F), -->
<!--            fail03XposEmo03 = scale(fail03*affEnerg, center = T, scale = F), -->
<!--            fail03XposEmo04 = scale(fail03*affInsp, center = T, scale = F), -->
<!--            fail03XposEmo05 = scale(fail03*affRel, center = T, scale = F) -->
<!--            ) -->

<!--   # calculate interactions for the latent constructs -->
<!--   dtCtry <- dtCtry %>% -->
<!--     mutate(fail01XposEmo01 = fail01*affCalm, -->
<!--            fail01XposEmo02 = fail01*affContent, -->
<!--            fail01XposEmo03 = fail01*affEnerg, -->
<!--            fail01XposEmo04 = fail01*affInsp, -->
<!--            fail01XposEmo05 = fail01*affRel, -->
<!--            fail02XposEmo01 = fail02*affCalm, -->
<!--            fail02XposEmo02 = fail02*affContent, -->
<!--            fail02XposEmo03 = fail02*affEnerg, -->
<!--            fail02XposEmo04 = fail02*affInsp, -->
<!--            fail02XposEmo05 = fail02*affRel, -->
<!--            fail03XposEmo01 = fail03*affCalm, -->
<!--            fail03XposEmo02 = fail03*affContent, -->
<!--            fail03XposEmo03 = fail03*affEnerg, -->
<!--            fail03XposEmo04 = fail03*affInsp, -->
<!--            fail03XposEmo05 = fail03*affRel -->
<!--            ) -->
<!-- ``` -->


<!-- ### posEmo - WB - proSo  -->
<!-- #### Normal SEM -->
<!-- ```{r} -->
<!-- model <- '# Model  -->
<!--             posEmo  =~ affCalm + affContent + affEnerg + affInsp + affRel  -->
<!--             WB =~ happy + lifeSat + MLQ -->
<!--             c19ProSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03 + c19ProSo04 -->
<!--           # Regression -->
<!--             c19ProSo ~ a*posEmo -->
<!--             WB ~ b*c19ProSo + c*posEmo' -->
<!-- fit <- sem(model, data = dtCtry) -->
<!-- summary(fit, fit.measures=TRUE) -->
<!-- lavaanPlot::lavaanPlot(model = fit, coefs = T, covs = T) -->


<!-- ``` -->

<!-- #### Multilevel SEM Model 1-1-1 -->
<!-- First we run a model that has no specified level 2 (only covariances) -->
<!-- ```{r} -->
<!-- # Explanation for below (from: https://www.youtube.com/watch?v=GZMXEq7GPvY): -->
<!-- # By adding the same model again on level 2, we are estimating the latent means now -->
<!-- # saturated model on level 2 -->
<!--   model <- 'level:1 -->
<!--             c19ProSo.c ~ a*posEmo.c -->
<!--             WB.m ~ b*c19ProSo.c + c*posEmo.c -->
<!--             level:2 -->
<!--             c19ProSo.c ~~ posEmo.c -->
<!--             c19ProSo.c ~~ WB.m -->
<!--             WB.m ~~ posEmo.c -->
<!--             # Indirect effects -->
<!--             ab:=a*b -->
<!--             total:=ab+c' -->
<!-- fit <- sem(model, data = dtCtry, cluster = "coded_country") -->
<!-- summary(fit, fit.measures=TRUE) -->
<!-- ``` -->

<!-- Next we run a model that also has no level 2 specified (only intercepts) -->
<!-- ```{r} -->
<!-- # level 2 only intercepts -->
<!--   model <- 'level:1 -->
<!--             c19ProSo.c ~ a*posEmo.c -->
<!--             WB.m ~ b*c19ProSo.c + c*posEmo.c -->
<!--             level:2 -->
<!--             c19ProSo.c ~ 1 -->
<!--             posEmo.c ~1 -->
<!--             WB.m ~ 1 -->
<!--             # Indirect effects -->
<!--             ab:=a*b -->
<!--             total:=ab+c' -->
<!-- fit <- sem(model, data = dtCtry, cluster = "coded_country") -->
<!-- summary(fit, fit.measures=TRUE) -->
<!-- ``` -->

<!-- Finally we run a model in which the level 2 structure mirrors level 1. This means that on level 2 we model the intercepts (means) and one level 1 the values. -->
<!-- ```{r} -->
<!-- # specified model -->
<!-- model <- 'level:1 -->
<!--           c19ProSo.c ~ a*posEmo.c -->
<!--           WB.m ~ b*c19ProSo.c + c*posEmo.c -->
<!--           level:2 -->
<!--           c19ProSo.c ~ d*posEmo.c -->
<!--           WB.m ~ e*c19ProSo.c + f*posEmo.c -->
<!--           # Indirect and total effects within -->
<!--           ab:=a*b -->
<!--           totalwith:=ab+c  -->
<!--           # Indirect and total effects between -->
<!--           de:=d*e -->
<!--           totalbw:=de+f'  -->
<!-- fit <- sem(model, data = dtCtry, cluster = "coded_country") -->
<!-- summary(fit, fit.measures=TRUE) -->
<!-- lavInspect(fit, "icc") -->
<!-- ``` -->

<!-- ### predictors - WB   -->
<!-- #### Multilevel SEM (latent vars) -->
<!-- ##### First: Measurement model -->
<!-- We run a model in which the level 2 structure mirrors level 1. This means that on level 2 we model the intercepts (means) and one level 1 the values. -->
<!-- In this first step, we test the measurement model to see whether the constructs even fit. Fit indeces seem adequate. -->
<!-- ```{r} -->
<!-- # Explanation for below (from: https://www.youtube.com/watch?v=GZMXEq7GPvY): -->
<!-- # By adding the same model again on level 2, we are estimating the latent means now -->
<!--   model <- 'level:1 -->
<!--             # Latent -->
<!--             posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel  -->
<!--             negEmo =~ affAnx + affDepr + affNerv + affExh -->
<!--             PFS =~ PFS01 + PFS02 + PFS03 -->
<!--             disemp =~ fail01 + fail02 + fail03 -->
<!--             wellBe =~ happy + lifeSat + MLQ -->
<!--             proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03 -->
<!--             level:2 -->
<!--             posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel -->
<!--             negEmo =~ affAnx + affDepr + affNerv + affExh -->
<!--             disemp =~ fail01 + fail02 + fail03 -->
<!--             PFS =~ PFS01 + PFS02 + PFS03 -->
<!--             wellBe =~ happy + lifeSat + MLQ -->
<!--             proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03' -->
<!-- fit <- sem(model, data = dtCtry, cluster = "coded_country") -->
<!-- fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em", verbose = T, em.iter.max = 20000, em.fx.tol = 1e-08, em.dx.tol = 1e-04) -->
<!-- summary(fit, fit.measures=TRUE) -->
<!-- lavaanPlot::lavaanPlot(model = fit, coefs = T, covs = T) -->

<!-- ``` -->

<!-- ##### Second: Regression Model -->
<!-- ```{r} -->
<!--   model <- 'level:1 -->
<!--           # Latent IVs -->
<!--             posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel  -->
<!--             negEmo =~ affAnx + affDepr + affNerv + affExh -->
<!--             PFS =~ PFS01 + PFS02 + PFS03 -->
<!--             disemp =~ fail01 + fail02 + fail03 -->
<!--           # Latent Mediator -->
<!--             wellBe =~ happy + lifeSat + MLQ -->
<!--           # Latent DV -->
<!--             proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03 -->
<!--           # Regression -->
<!--             wellBe ~ a1*posEmo + a2*negEmo + a3*PFS + a4*disemp -->
<!--             level:2 -->
<!--           # Latent -->
<!--             posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel -->
<!--             negEmo =~ affAnx + affDepr + affNerv + affExh -->
<!--             disemp =~ fail01 + fail02 + fail03 -->
<!--             PFS =~ PFS01 + PFS02 + PFS03 -->
<!--             wellBe =~ happy + lifeSat + MLQ -->
<!--             proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03 -->
<!--           # Regression -->
<!--             wellBe ~ d1*posEmo + d2*negEmo + d3*PFS + d4*disemp' -->
<!-- #fit <- sem(model, data = dtCtry, cluster = "coded_country") -->
<!-- fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em", verbose = T, em.iter.max = 20000, -->
<!--            em.fx.tol = 1e-08, em.dx.tol = 1e-04) -->
<!-- lavaanPlot::lavaanPlot(model = fit, coefs = T, covs = T) -->
<!-- ``` -->

<!-- ##### Third: Interaction Model -->
<!-- ```{r} -->
<!--   model <- 'level:1 -->
<!--           # Latent Constructs -->
<!--             posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel  -->
<!--             negEmo =~ affAnx + affDepr + affNerv + affExh -->
<!--             PFS =~ PFS01 + PFS02 + PFS03 -->
<!--             disemp =~ fail01 + fail02 + fail03 -->
<!--             wellBe =~ happy + lifeSat + MLQ -->
<!--             proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03 -->
<!--           # Interactions -->
<!--             failXposEmo =~ fail01XposEmo01 + fail01XposEmo02 + fail01XposEmo03 + fail01XposEmo04 + fail01XposEmo05 + fail02XposEmo01 + fail02XposEmo02 + fail02XposEmo03 + fail02XposEmo04 + fail02XposEmo05 + fail03XposEmo01 + fail03XposEmo02 + fail03XposEmo03 + fail03XposEmo04 + fail03XposEmo05 -->
<!--           # Regression -->
<!--             wellBe ~ a1*posEmo + a2*negEmo + a3*PFS + a4*disemp + a5*failXposEmo -->
<!--             level:2 -->
<!--           # Latent Constructs -->
<!--             posEmo =~ affCalm + affContent + affEnerg + affInsp + affRel -->
<!--             negEmo =~ affAnx + affDepr + affNerv + affExh -->
<!--             disemp =~ fail01 + fail02 + fail03 -->
<!--             PFS =~ PFS01 + PFS02 + PFS03 -->
<!--             wellBe =~ happy + lifeSat + MLQ -->
<!--             proSo =~ c19ProSo01 + c19ProSo02 + c19ProSo03 -->
<!--           # Interactions -->
<!--             failXposEmo =~ fail01XposEmo01 + fail01XposEmo02 + fail01XposEmo03 + fail01XposEmo04 + fail01XposEmo05 + fail02XposEmo01 + fail02XposEmo02 + fail02XposEmo03 + fail02XposEmo04 + fail02XposEmo05 + fail03XposEmo01 + fail03XposEmo02 + fail03XposEmo03 + fail03XposEmo04 + fail03XposEmo05 -->
<!--           # Regression -->
<!--             wellBe ~ d1*posEmo + d2*negEmo + d3*PFS + d4*disemp + d6*failXposEmo' -->

<!-- fit <- sem(model, data = dtCtry, cluster = "coded_country", optim.method = "em", verbose = T, em.iter.max = 20000, em.fx.tol = 1e-08, em.dx.tol = 1e-04) -->
<!-- summary(fit, fit.measures=TRUE) -->
<!--  lavaanPlot::lavaanPlot(model = fit, coefs = T, covs = T) -->

<!-- # semTools::plotProbe (probe a latent interaction) https://rdrr.io/cran/semTools/man/plotProbe.html -->

<!-- ``` -->

<!-- ## Longitudinal -->
<!-- ```{r} -->

<!-- # use growth() from lavaan package with cluster -->
<!-- ``` -->

